class VisualGrouperClassical:
    # ### ИСПРАВЛЕНО: Добавили аргумент `prs` (объект презентации)
    def __init__(self, slide, image_path, prs):
        self.slide = slide
        self.img = cv2.imread(image_path)
        
        if self.img is None:
            raise ValueError(f"Не удалось прочитать картинку: {image_path}")
            
        self.h, self.w = self.img.shape[:2]
        
        # ### ИСПРАВЛЕНО: Берем размеры из переданного объекта prs
        # prs.slide_width и prs.slide_height хранят размеры в EMU
        self.scale_x = self.w / prs.slide_width
        self.scale_y = self.h / prs.slide_height

    def emu_to_pixels(self, shape):
        x = int(shape.left * self.scale_x)
        y = int(shape.top * self.scale_y)
        w = int(shape.width * self.scale_x)
        h = int(shape.height * self.scale_y)
        return [x, y, x + w, y + h]

    def detect_layout_blocks(self):
        gray = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)
        _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

        # Настройка ядра: (30, 25) - можно менять
        kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (30, 25))
        dilated = cv2.dilate(thresh, kernel, iterations=3)

        contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        blocks = []
        for cnt in contours:
            x, y, w, h = cv2.boundingRect(cnt)
            if w < 50 or h < 50: continue
            if w > self.w * 0.95 and h > self.h * 0.95: continue
            
            blocks.append({
                "bbox": [x, y, x + w, y + h],
                "elements": []
            })
            
        return blocks

    def get_intersection(self, boxA, boxB):
        xA = max(boxA[0], boxB[0])
        yA = max(boxA[1], boxB[1])
        xB = min(boxA[2], boxB[2])
        yB = min(boxA[3], boxB[3])
        
        interArea = max(0, xB - xA) * max(0, yB - yA)
        if interArea == 0: return 0
        
        boxAArea = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
        if boxAArea == 0: return 0
        
        return interArea / boxAArea

    def group_elements(self):
        blocks = self.detect_layout_blocks()
        orphans = []

        for shape in self.slide.shapes:
            if not hasattr(shape, "left"): continue
            
            shape_rect = self.emu_to_pixels(shape)
            
            best_score = 0
            best_block_idx = -1
            
            for i, block in enumerate(blocks):
                score = self.get_intersection(shape_rect, block["bbox"])
                if score > 0.3 and score > best_score:
                    best_score = score
                    best_block_idx = i
            
            if best_block_idx != -1:
                blocks[best_block_idx]["elements"].append(shape)
            else:
                orphans.append(shape)

        blocks.sort(key=lambda b: b["bbox"][1])
        return blocks, orphans

# ==========================================
# 3. ЗАПУСК
# ==========================================
if __name__ == "__main__":
    PPTX_FILE = "test.pptx"
    IMG_FOLDER = "temp_images"
    
    if not os.path.exists(PPTX_FILE):
        print(f"Файл {PPTX_FILE} не найден!")
        exit()

    print("1. Генерация картинок...")
    image_paths = export_slides_to_images(PPTX_FILE, IMG_FOLDER)
    
    if not image_paths:
        print("Ошибка генерации картинок.")
        exit()

    print("2. Анализ...")
    # Создаем объект презентации
    prs = Presentation(PPTX_FILE)
    
    full_result = []

    for i, slide in enumerate(prs.slides):
        print(f"--- Слайд {i+1} ---")
        img_path = image_paths[i]
        
        # ### ИСПРАВЛЕНО: Передаем `prs` третьим аргументом
        grouper = VisualGrouperClassical(slide, img_path, prs)
        
        blocks, orphans = grouper.group_elements()
        
        # ... дальнейший код формирования JSON (как в прошлом примере) ...
        slide_data = {"slide_number": i+1, "groups": []}
        
        for block in blocks:
            if not block["elements"]: continue
            
            elements = sorted(block["elements"], key=lambda s: s.top)
            
            group_obj = {
                "type": "content_block",
                "text_content": "",
                "data_objects": []
            }
            texts = []
            
            for el in elements:
                if hasattr(el, "text") and el.text.strip():
                    texts.append(el.text.strip())
                if el.has_chart:
                    group_obj["type"] = "chart_group"
                    group_obj["data_objects"].append({"info": "Chart found"})
                if el.has_table:
                    group_obj["type"] = "table_group"
                    group_obj["data_objects"].append({"info": "Table found"})

            group_obj["text_content"] = "\n".join(texts)
            slide_data["groups"].append(group_obj)
            
        full_result.append(slide_data)

    print(json.dumps(full_result, indent=2, ensure_ascii=False))
