"""
Гибридный парсер PPTX с правильной CV-детекцией отдельных блоков.

Исправлено:
1. CV выделяет ОТДЕЛЬНЫЕ блоки, а не один большой
2. Связывание элементов между блоками (заголовок → график)
3. Корректная обработка текстовых слайдов с колонками
"""

import cv2
import numpy as np
import json
import os
import random
import platform
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Set, Any
from enum import Enum
from collections import defaultdict

from pptx import Presentation
from pptx.shapes.group import GroupShape
from pptx.shapes.graphfrm import GraphicFrame
from pptx.enum.shapes import PP_PLACEHOLDER


# ==========================================
# КОНФИГУРАЦИЯ
# ==========================================

CONFIG = {
    # Дефолтные параметры CV-детекции (КОНСЕРВАТИВНЫЕ - не сливают блоки)
    "default_cv_params": {
        "min_threshold": 30,
        "max_threshold": 120,
        "ksize_width": 3,
        "ksize_height": 15,      # Маленькое значение - не сливает по вертикали
        "dilate_iterations": 3,   # Меньше итераций - меньше слияние
        "min_intersection_score": 0.20
    },
    
    # Стратегии оптимизации CV-параметров
    "cv_strategies": {
        # Консервативная - выделяет много отдельных блоков
        "conservative": {
            "min_threshold": (25, 45),
            "max_threshold": (100, 160),
            "ksize_width": (2, 4),
            "ksize_height": (8, 18),
            "dilate_iterations": (2, 4),
            "min_intersection_score": (0.18, 0.30)
        },
        # Сбалансированная
        "balanced": {
            "min_threshold": (20, 35),
            "max_threshold": (90, 140),
            "ksize_width": (3, 6),
            "ksize_height": (12, 25),
            "dilate_iterations": (3, 5),
            "min_intersection_score": (0.15, 0.25)
        },
        # Для горизонтального объединения (колонки)
        "horizontal_merge": {
            "min_threshold": (15, 30),
            "max_threshold": (80, 130),
            "ksize_width": (8, 15),
            "ksize_height": (10, 20),
            "dilate_iterations": (3, 5),
            "min_intersection_score": (0.12, 0.22)
        },
        # Для вертикального объединения (заголовок + контент)
        "vertical_merge": {
            "min_threshold": (20, 35),
            "max_threshold": (90, 150),
            "ksize_width": (2, 5),
            "ksize_height": (25, 45),
            "dilate_iterations": (4, 6),
            "min_intersection_score": (0.12, 0.22)
        },
        # Агрессивная - для сложных случаев
        "aggressive": {
            "min_threshold": (10, 25),
            "max_threshold": (60, 110),
            "ksize_width": (6, 12),
            "ksize_height": (30, 55),
            "dilate_iterations": (5, 8),
            "min_intersection_score": (0.08, 0.18)
        }
    },
    
    # Параметры оптимизации
    "optimization": {
        "iterations_per_strategy": 4,
        "min_acceptable_score": 0.45,
        "early_stop_score": 0.82,
        "prefer_more_blocks": True,  # Предпочитать больше отдельных блоков
    },
    
    # Параметры оценки качества
    "quality": {
        "target_orphan_ratio": 0.15,
        "target_block_range": (3, 25),      # Ожидаем больше блоков
        "min_blocks_with_content": 2,       # Минимум блоков с контентом
        "bonus_chart_with_title": 0.12,
        "bonus_multi_element_block": 0.08,
        "bonus_separate_logical_blocks": 0.1,  # Бонус за отдельные логические блоки
        "penalty_isolated_title": 0.15,
        "penalty_chart_without_title": 0.12,
        "penalty_single_huge_block": 0.25,    # Штраф если всё в одном блоке
    },
    
    # Параметры группировки
    "grouping": {
        "max_title_distance": 70,
        "max_legend_distance_x": 100,
        "max_legend_distance_y": 45,
        "column_gap_ratio": 0.05,
        "merge_blocks_max_gap": 50,    # Макс. расстояние для объединения блоков
        "min_block_area_ratio": 0.005, # Мин. площадь блока относительно слайда
    },
    
    # Классификация
    "classification": {
        "header_zone_ratio": 0.18,
        "footer_zone_ratio": 0.85,
        "min_importance_for_header": 0.20,
    },
    
    # Debug
    "debug": {
        "save_contours": True,
        "output_dir": "debug_contours"
    }
}


# ==========================================
# ТИПЫ И СТРУКТУРЫ
# ==========================================

class ElementRole(Enum):
    SLIDE_TITLE = "slide_title"
    SECTION_HEADER = "section_header"
    CONTENT_TITLE = "content_title"
    BODY_TEXT = "body_text"
    BULLET_POINT = "bullet_point"
    CHART = "chart"
    TABLE = "table"
    LEGEND = "legend"
    FOOTNOTE = "footnote"
    IMAGE = "image"
    UNKNOWN = "unknown"


@dataclass
class CVParams:
    """Параметры CV-детекции"""
    min_threshold: int = 30
    max_threshold: int = 120
    ksize_width: int = 3
    ksize_height: int = 15
    dilate_iterations: int = 3
    min_intersection_score: float = 0.20
    strategy_name: str = "default"
    
    def to_dict(self) -> Dict:
        return {
            "min_threshold": self.min_threshold,
            "max_threshold": self.max_threshold,
            "ksize_width": self.ksize_width,
            "ksize_height": self.ksize_height,
            "dilate_iterations": self.dilate_iterations,
            "min_intersection_score": self.min_intersection_score,
            "strategy": self.strategy_name
        }


@dataclass
class TextFormatting:
    """Форматирование текста"""
    font_size: Optional[float] = None
    is_bold: bool = False
    is_title_placeholder: bool = False
    indent_level: int = 0
    has_bullet: bool = False
    
    @property
    def importance_score(self) -> float:
        score = 0.0
        if self.is_title_placeholder:
            score += 0.5
        if self.font_size:
            score += min(0.3, max(0, (self.font_size - 12) / 40))
        if self.is_bold:
            score += 0.12
        if not self.has_bullet:
            score += 0.04
        if self.indent_level == 0:
            score += 0.04
        return min(1.0, score)


@dataclass
class LayoutElement:
    """Элемент слайда"""
    shape: Any
    role: ElementRole
    bbox: Tuple[int, int, int, int]
    text: str = ""
    formatting: TextFormatting = field(default_factory=TextFormatting)
    native_group_id: Optional[int] = None
    cv_block_id: Optional[int] = None
    column_id: Optional[int] = None
    reading_order: int = 0
    
    @property
    def center_x(self) -> float:
        return (self.bbox[0] + self.bbox[2]) / 2
    
    @property
    def center_y(self) -> float:
        return (self.bbox[1] + self.bbox[3]) / 2
    
    @property
    def width(self) -> int:
        return self.bbox[2] - self.bbox[0]
    
    @property
    def height(self) -> int:
        return self.bbox[3] - self.bbox[1]
    
    @property
    def area(self) -> int:
        return self.width * self.height
    
    @property
    def is_visual(self) -> bool:
        return self.role in (ElementRole.CHART, ElementRole.TABLE)
    
    @property
    def is_header_like(self) -> bool:
        return self.role in (
            ElementRole.SLIDE_TITLE,
            ElementRole.SECTION_HEADER,
            ElementRole.CONTENT_TITLE
        )


@dataclass
class CVBlock:
    """Блок от CV-детекции"""
    bbox: Tuple[int, int, int, int]
    block_id: int
    elements: List[LayoutElement] = field(default_factory=list)
    merged_with: Optional[int] = None  # ID блока, с которым объединён
    
    @property
    def center_x(self) -> float:
        return (self.bbox[0] + self.bbox[2]) / 2
    
    @property
    def center_y(self) -> float:
        return (self.bbox[1] + self.bbox[3]) / 2
    
    @property
    def width(self) -> int:
        return self.bbox[2] - self.bbox[0]
    
    @property
    def height(self) -> int:
        return self.bbox[3] - self.bbox[1]
    
    @property
    def area(self) -> int:
        return self.width * self.height


@dataclass
class ContentGroup:
    """Группа связанного контента"""
    elements: List[LayoutElement] = field(default_factory=list)
    group_type: str = "unknown"
    header: Optional[LayoutElement] = None
    visual_content: Optional[LayoutElement] = None
    cv_block_ids: List[int] = field(default_factory=list)
    native_group_id: Optional[int] = None
    column_id: Optional[int] = None
    
    @property
    def bbox(self) -> Tuple[int, int, int, int]:
        if not self.elements:
            return (0, 0, 0, 0)
        return (
            min(e.bbox[0] for e in self.elements),
            min(e.bbox[1] for e in self.elements),
            max(e.bbox[2] for e in self.elements),
            max(e.bbox[3] for e in self.elements)
        )
    
    @property
    def has_visual(self) -> bool:
        return self.visual_content is not None
    
    @property
    def has_header(self) -> bool:
        return self.header is not None


@dataclass
class QualityMetrics:
    """Метрики качества группировки"""
    total_elements: int = 0
    total_blocks: int = 0
    total_cv_blocks: int = 0
    orphan_count: int = 0
    orphan_ratio: float = 0.0
    charts_with_title: int = 0
    charts_without_title: int = 0
    isolated_titles: int = 0
    multi_element_groups: int = 0
    single_huge_block: bool = False
    score: float = 0.0
    
    def to_dict(self) -> Dict:
        return {
            "total_elements": self.total_elements,
            "total_blocks": self.total_blocks,
            "total_cv_blocks": self.total_cv_blocks,
            "orphan_count": self.orphan_count,
            "orphan_ratio": round(self.orphan_ratio, 3),
            "charts_with_title": self.charts_with_title,
            "charts_without_title": self.charts_without_title,
            "isolated_titles": self.isolated_titles,
            "multi_element_groups": self.multi_element_groups,
            "single_huge_block": self.single_huge_block,
            "score": round(self.score, 3)
        }


# ==========================================
# КЛАСС ДЛЯ ГЕНЕРАЦИИ ИЗОБРАЖЕНИЙ
# ==========================================

class SlideImageExporter:
    @staticmethod
    def export(pptx_path: str, output_folder: str, dpi: int = 96) -> list[str]:
        abs_pptx = os.path.abspath(pptx_path)
        abs_output = os.path.abspath(output_folder)

        if not os.path.exists(abs_pptx):
            raise FileNotFoundError(f"Файл презентации не найден: {abs_pptx}")

        if not os.path.exists(abs_output):
            os.makedirs(abs_output, exist_ok=True)

        os_type = platform.system()

        if os_type == "Windows":
            return SlideImageExporter._export_windows(abs_pptx, abs_output)
        elif os_type in ["Linux", "Darwin"]:
            return SlideImageExporter._export_linux(abs_pptx, abs_output, dpi)
        else:
            raise NotImplementedError(f"Неподдерживаемая ОС: {os_type}")

    @staticmethod
    def _export_windows(pptx_path: str, output_folder: str) -> list[str]:
        try:
            import win32com.client
        except ImportError:
            raise ImportError(
                "Для работы под Windows требуется библиотека pywin32. "
                "Установите её: pip install pywin32"
            )

        paths = []
        powerpoint = None
        pres = None

        try:
            powerpoint = win32com.client.Dispatch("PowerPoint.Application")
            pres = powerpoint.Presentations.Open(pptx_path, WithWindow=False)

            for i, slide in enumerate(pres.Slides):
                fname = os.path.join(output_folder, f"slide_{i + 1}.jpg")
                if os.path.exists(fname):
                    os.remove(fname)
                slide.Export(fname, "JPG", 0, 0)
                paths.append(fname)

            if pres:
                pres.Close()
            if powerpoint:
                powerpoint.Quit()

            return paths

        except Exception as e:
            print(f"Ошибка при экспорте в Windows: {e}")
            return []
        finally:
            try:
                if pres:
                    del pres
                if powerpoint:
                    del powerpoint
            except:
                pass

    @staticmethod
    def _export_linux(pptx_path: str, output_folder: str, dpi: int = 96) -> list[str]:
        result = SlideImageExporter.export_via_libreoffice(pptx_path, output_folder, dpi)
        if result:
            return result
        
        print("Внимание: не удалось экспортировать слайды.")
        return []

    @staticmethod
    def export_via_libreoffice(pptx_path: str, output_folder: str, dpi: int = 96) -> list[str]:
        import subprocess

        abs_pptx = os.path.abspath(pptx_path)
        abs_output = os.path.abspath(output_folder)

        if not os.path.exists(abs_output):
            os.makedirs(abs_output, exist_ok=True)

        paths = []

        try:
            cmd = [
                'libreoffice', '--headless', '--convert-to', 'jpg',
                '--outdir', abs_output, abs_pptx
            ]

            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                print(f"Ошибка LibreOffice: {result.stderr}")
                return []

            base_name = os.path.splitext(os.path.basename(abs_pptx))[0]

            for i in range(1, 100):
                fname = os.path.join(abs_output, f"{base_name}_{i}.jpg")
                if os.path.exists(fname):
                    paths.append(fname)
                else:
                    alt_fname = os.path.join(abs_output, f"slide_{i}.jpg")
                    if os.path.exists(alt_fname):
                        paths.append(alt_fname)
                    else:
                        break

            return paths

        except FileNotFoundError:
            print("LibreOffice не найден.")
            return []
        except Exception as e:
            print(f"Ошибка при конвертации через LibreOffice: {e}")
            return []


# ==========================================
# CV ДЕТЕКТОР С ПРАВИЛЬНЫМ РАЗДЕЛЕНИЕМ БЛОКОВ
# ==========================================

class CVBlockDetector:
    """
    Детекция ОТДЕЛЬНЫХ визуальных блоков через OpenCV.
    Ключевое отличие: находит границы между блоками, а не сливает всё в один.
    """
    
    def __init__(self, image_path: str):
        self.image_path = image_path
        self.img = cv2.imread(image_path)
        if self.img is None:
            raise ValueError(f"Cannot load image: {image_path}")
        self.h, self.w = self.img.shape[:2]
        self.slide_area = self.h * self.w
    
    def detect_blocks(self, params: CVParams, 
                      debug_save: bool = False,
                      debug_prefix: str = "") -> List[CVBlock]:
        """
        Детекция блоков с заданными параметрами.
        Возвращает ОТДЕЛЬНЫЕ визуальные блоки.
        """
        gray = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)
        
        # Canny edge detection
        edges = cv2.Canny(gray, params.min_threshold, params.max_threshold)
        
        # Морфологическое ядро
        kernel = cv2.getStructuringElement(
            cv2.MORPH_RECT,
            (params.ksize_width, params.ksize_height)
        )
        
        # Дилатация для объединения близких элементов
        dilated = cv2.dilate(edges, kernel, iterations=params.dilate_iterations)
        
        # Поиск контуров
        contours, hierarchy = cv2.findContours(
            dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        
        # Сохранение debug-изображения
        if debug_save and CONFIG["debug"]["save_contours"]:
            self._save_debug_image(contours, params, debug_prefix)
        
        # Формирование блоков с фильтрацией
        blocks = []
        min_area = self.slide_area * CONFIG["grouping"]["min_block_area_ratio"]
        
        for i, cnt in enumerate(contours):
            x, y, w, h = cv2.boundingRect(cnt)
            area = w * h
            
            # Фильтрация слишком мелких
            if w < 20 or h < 15:
                continue
            if area < min_area:
                continue
            
            # Фильтрация слишком больших (почти весь слайд)
            if w > self.w * 0.95 and h > self.h * 0.95:
                continue
            
            blocks.append(CVBlock(
                bbox=(x, y, x + w, y + h),
                block_id=len(blocks)
            ))
        
        # Сортировка по позиции (сверху-вниз, слева-направо)
        blocks.sort(key=lambda b: (b.bbox[1], b.bbox[0]))
        
        # Переназначаем ID после сортировки
        for i, block in enumerate(blocks):
            block.block_id = i
        
        return blocks
    
    def _save_debug_image(self, contours, params: CVParams, prefix: str):
        """Сохраняет изображение с контурами для отладки"""
        debug_dir = CONFIG["debug"]["output_dir"]
        os.makedirs(debug_dir, exist_ok=True)
        
        img_copy = self.img.copy()
        
        # Рисуем контуры зелёным
        cv2.drawContours(img_copy, contours, -1, (0, 255, 0), 2)
        
        # Добавляем информацию о параметрах
        info_text = f"kh={params.ksize_height} kw={params.ksize_width} di={params.dilate_iterations}"
        cv2.putText(img_copy, info_text, (10, 30), 
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
        cv2.putText(img_copy, f"blocks={len(contours)}", (10, 60),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
        
        filename = f"{prefix}_{params.strategy_name}.jpg"
        cv2.imwrite(os.path.join(debug_dir, filename), img_copy)
    
    def detect_with_multiple_scales(self) -> List[List[CVBlock]]:
        """
        Детекция на нескольких масштабах для сложных слайдов.
        Возвращает список вариантов блоков.
        """
        results = []
        
        # Мелкое разбиение (много блоков)
        fine_params = CVParams(
            min_threshold=35, max_threshold=130,
            ksize_width=2, ksize_height=10,
            dilate_iterations=2, strategy_name="fine"
        )
        results.append(self.detect_blocks(fine_params))
        
        # Среднее разбиение
        medium_params = CVParams(
            min_threshold=25, max_threshold=110,
            ksize_width=4, ksize_height=20,
            dilate_iterations=4, strategy_name="medium"
        )
        results.append(self.detect_blocks(medium_params))
        
        # Крупное разбиение (меньше блоков)
        coarse_params = CVParams(
            min_threshold=15, max_threshold=90,
            ksize_width=6, ksize_height=35,
            dilate_iterations=6, strategy_name="coarse"
        )
        results.append(self.detect_blocks(coarse_params))
        
        return results


# ==========================================
# АНАЛИЗАТОР ФОРМАТИРОВАНИЯ
# ==========================================

class FormattingAnalyzer:
    """Анализ форматирования текста из PowerPoint"""
    
    TITLE_PLACEHOLDERS = {
        PP_PLACEHOLDER.TITLE,
        PP_PLACEHOLDER.CENTER_TITLE,
        PP_PLACEHOLDER.SUBTITLE,
    }
    
    @staticmethod
    def analyze(shape) -> TextFormatting:
        formatting = TextFormatting()
        
        try:
            if hasattr(shape, 'placeholder_format') and shape.placeholder_format:
                if shape.placeholder_format.type in FormattingAnalyzer.TITLE_PLACEHOLDERS:
                    formatting.is_title_placeholder = True
        except:
            pass
        
        try:
            if hasattr(shape, 'text_frame') and shape.text_frame.paragraphs:
                para = shape.text_frame.paragraphs[0]
                formatting.indent_level = para.level or 0
                
                try:
                    if hasattr(para, 'bullet') and para.bullet:
                        if para.bullet.type is not None:
                            formatting.has_bullet = True
                except:
                    pass
                
                if para.runs:
                    run = para.runs[0]
                    try:
                        if run.font.size:
                            formatting.font_size = run.font.size.pt
                    except:
                        pass
                    try:
                        if run.font.bold:
                            formatting.is_bold = True
                    except:
                        pass
        except:
            pass
        
        return formatting


# ==========================================
# КЛАССИФИКАТОР РОЛЕЙ
# ==========================================

class RoleClassifier:
    """Классификация ролей элементов"""
    
    def __init__(self, slide_width: int, slide_height: int):
        self.slide_width = slide_width
        self.slide_height = slide_height
        cfg = CONFIG["classification"]
        self.header_zone_y = slide_height * cfg["header_zone_ratio"]
        self.footer_zone_y = slide_height * cfg["footer_zone_ratio"]
    
    def classify_all(self, elements: List[LayoutElement], 
                     cv_blocks: List[CVBlock]) -> None:
        """Классифицирует все элементы"""
        # Первый проход: базовая классификация
        for elem in elements:
            if elem.role == ElementRole.UNKNOWN:
                elem.role = self._classify_basic(elem)
        
        # Второй проход: контекстная классификация
        for elem in elements:
            if elem.role in (ElementRole.BODY_TEXT, ElementRole.UNKNOWN):
                new_role = self._classify_contextual(elem, elements, cv_blocks)
                if new_role != ElementRole.UNKNOWN:
                    elem.role = new_role
    
    def _classify_basic(self, element: LayoutElement) -> ElementRole:
        shape = element.shape
        
        try:
            if hasattr(shape, 'has_chart') and shape.has_chart:
                return ElementRole.CHART
            if hasattr(shape, 'has_table') and shape.has_table:
                return ElementRole.TABLE
        except:
            pass
        
        formatting = element.formatting
        
        if formatting.is_title_placeholder:
            return ElementRole.SLIDE_TITLE
        
        if element.bbox[1] < self.header_zone_y:
            if formatting.importance_score > CONFIG["classification"]["min_importance_for_header"]:
                return ElementRole.SLIDE_TITLE
        
        if element.bbox[1] > self.footer_zone_y:
            if formatting.importance_score < 0.15 and element.height < self.slide_height * 0.05:
                return ElementRole.FOOTNOTE
        
        if formatting.has_bullet or formatting.indent_level > 0:
            return ElementRole.BULLET_POINT
        
        return ElementRole.BODY_TEXT
    
    def _classify_contextual(self, element: LayoutElement,
                             all_elements: List[LayoutElement],
                             cv_blocks: List[CVBlock]) -> ElementRole:
        
        if self._is_legend(element, all_elements):
            return ElementRole.LEGEND
        
        if self._is_content_title(element, all_elements, cv_blocks):
            return ElementRole.CONTENT_TITLE
        
        if self._is_section_header(element, all_elements):
            return ElementRole.SECTION_HEADER
        
        return ElementRole.UNKNOWN
    
    def _is_legend(self, element: LayoutElement,
                   all_elements: List[LayoutElement]) -> bool:
        if element.formatting.importance_score > 0.25:
            return False
        
        charts = [e for e in all_elements if e.role == ElementRole.CHART]
        
        for chart in charts:
            # Проверка: в том же CV-блоке
            same_block = (
                element.cv_block_id is not None and
                chart.cv_block_id is not None and
                element.cv_block_id == chart.cv_block_id
            )
            
            # Справа от графика
            is_right = (
                element.bbox[0] > chart.bbox[2] - 40 and
                element.bbox[0] < chart.bbox[2] + CONFIG["grouping"]["max_legend_distance_x"] and
                chart.bbox[1] - 30 < element.center_y < chart.bbox[3] + 30
            )
            
            # Снизу близко
            is_below = (
                element.bbox[1] > chart.bbox[3] and
                element.bbox[1] < chart.bbox[3] + CONFIG["grouping"]["max_legend_distance_y"] and
                abs(element.center_x - chart.center_x) < chart.width * 0.5 and
                element.formatting.importance_score < 0.18
            )
            
            if same_block and (is_right or is_below):
                return True
            
            if is_right and element.width < chart.width * 0.4:
                return True
        
        return False
    
    def _is_content_title(self, element: LayoutElement,
                          all_elements: List[LayoutElement],
                          cv_blocks: List[CVBlock]) -> bool:
        if element.formatting.importance_score < 0.10:
            return False
        
        visuals_below = [
            e for e in all_elements
            if e.is_visual and
            e.bbox[1] > element.bbox[3] and
            e.bbox[1] - element.bbox[3] < CONFIG["grouping"]["max_title_distance"]
        ]
        
        for visual in visuals_below:
            # Приоритет: тот же CV-блок
            same_cv = (
                element.cv_block_id is not None and
                visual.cv_block_id is not None and
                element.cv_block_id == visual.cv_block_id
            )
            
            aligned = self._is_aligned(element, visual)
            
            if same_cv or aligned:
                return True
        
        return False
    
    def _is_section_header(self, element: LayoutElement,
                           all_elements: List[LayoutElement]) -> bool:
        if element.formatting.importance_score < CONFIG["classification"]["min_importance_for_header"]:
            return False
        
        elements_below = [
            e for e in all_elements
            if e.bbox[1] > element.bbox[3] and
            not e.is_visual and
            e.role not in (ElementRole.FOOTNOTE, ElementRole.LEGEND) and
            self._is_aligned(element, e)
        ]
        
        if not elements_below:
            return False
        
        avg_importance = sum(e.formatting.importance_score for e in elements_below) / len(elements_below)
        return element.formatting.importance_score > avg_importance + 0.06
    
    def _is_aligned(self, elem1: LayoutElement, elem2: LayoutElement) -> bool:
        overlap = min(elem1.bbox[2], elem2.bbox[2]) - max(elem1.bbox[0], elem2.bbox[0])
        min_width = min(elem1.width, elem2.width)
        if min_width > 0 and overlap > min_width * 0.25:
            return True
        
        if abs(elem1.center_x - elem2.center_x) < min_width * 0.35:
            return True
        
        if abs(elem1.bbox[0] - elem2.bbox[0]) < 30:
            return True
        
        return False


# ==========================================
# ОЦЕНЩИК КАЧЕСТВА
# ==========================================

class QualityAssessor:
    """Оценка качества группировки"""
    
    @staticmethod
    def assess(groups: List[ContentGroup], 
               orphans: List[LayoutElement],
               total_elements: int,
               cv_blocks_count: int,
               slide_area: int) -> QualityMetrics:
        """Вычисляет метрики качества"""
        metrics = QualityMetrics()
        metrics.total_elements = total_elements
        metrics.total_blocks = len(groups)
        metrics.total_cv_blocks = cv_blocks_count
        metrics.orphan_count = len(orphans)
        metrics.orphan_ratio = len(orphans) / total_elements if total_elements > 0 else 0
        
        cfg = CONFIG["quality"]
        
        # Проверка на "один огромный блок"
        if cv_blocks_count == 1 and total_elements > 3:
            metrics.single_huge_block = True
        
        for group in groups:
            if group.has_visual:
                if group.has_header:
                    metrics.charts_with_title += 1
                else:
                    metrics.charts_without_title += 1
            
            if group.has_header and len(group.elements) == 1:
                metrics.isolated_titles += 1
            
            if len(group.elements) > 1:
                metrics.multi_element_groups += 1
        
        # Вычисление score
        score = 1.0
        
        # Штраф за orphans
        if metrics.orphan_ratio > cfg["target_orphan_ratio"]:
            excess = metrics.orphan_ratio - cfg["target_orphan_ratio"]
            score -= min(0.35, excess * 1.8)
        
        # Штраф за один огромный блок (плохое разделение)
        if metrics.single_huge_block:
            score -= cfg["penalty_single_huge_block"]
        
        # Проверка диапазона блоков
        target_min, target_max = cfg["target_block_range"]
        if metrics.total_blocks < target_min:
            score -= 0.12
        elif metrics.total_blocks > target_max:
            score -= min(0.15, (metrics.total_blocks - target_max) * 0.015)
        
        # Бонус за графики с заголовками
        if metrics.charts_with_title > 0:
            total_charts = metrics.charts_with_title + metrics.charts_without_title
            if total_charts > 0:
                ratio = metrics.charts_with_title / total_charts
                score += ratio * cfg["bonus_chart_with_title"]
        
        # Штрафы
        score -= metrics.charts_without_title * cfg["penalty_chart_without_title"]
        score -= metrics.isolated_titles * cfg["penalty_isolated_title"]
        
        # Бонус за многоэлементные группы
        if metrics.total_blocks > 0:
            multi_ratio = metrics.multi_element_groups / metrics.total_blocks
            score += multi_ratio * cfg["bonus_multi_element_block"]
        
        # Бонус за хорошее разделение на отдельные блоки
        if cv_blocks_count >= 2 and not metrics.single_huge_block:
            score += cfg["bonus_separate_logical_blocks"]
        
        metrics.score = max(0.0, min(1.0, score))
        
        return metrics


# ==========================================
# ОПТИМИЗАТОР ПАРАМЕТРОВ
# ==========================================

class ParameterOptimizer:
    """Динамическая оптимизация параметров CV"""
    
    def __init__(self, cv_detector: CVBlockDetector, slide_area: int):
        self.cv_detector = cv_detector
        self.slide_area = slide_area
    
    def optimize(self, elements: List[LayoutElement],
                 slide_index: int) -> Tuple[CVParams, List[CVBlock], QualityMetrics]:
        """Находит оптимальные параметры для слайда"""
        best_params = None
        best_blocks = None
        best_metrics = None
        best_score = -1
        
        strategies = CONFIG["cv_strategies"]
        iterations = CONFIG["optimization"]["iterations_per_strategy"]
        early_stop = CONFIG["optimization"]["early_stop_score"]
        
        # Порядок стратегий: от консервативных к агрессивным
        strategy_order = ["conservative", "balanced", "horizontal_merge", "vertical_merge", "aggressive"]
        
        for strategy_name in strategy_order:
            if strategy_name not in strategies:
                continue
            ranges = strategies[strategy_name]
            
            for i in range(iterations):
                params = self._generate_params(ranges, strategy_name)
                
                try:
                    blocks = self.cv_detector.detect_blocks(
                        params,
                        debug_save=(i == 0),
                        debug_prefix=f"slide_{slide_index:03d}"
                    )
                    
                    # Пропускаем если блоков слишком мало или много
                    if len(blocks) < 1 or len(blocks) > 50:
                        continue
                    
                    self._assign_elements_to_blocks(elements, blocks, params.min_intersection_score)
                    
                    groups, orphans = self._quick_group(elements, blocks)
                    
                    metrics = QualityAssessor.assess(
                        groups, orphans, len(elements), 
                        len(blocks), self.slide_area
                    )
                    
                    # Предпочитаем больше отдельных блоков
                    adjusted_score = metrics.score
                    if CONFIG["optimization"]["prefer_more_blocks"]:
                        if len(blocks) >= 3 and not metrics.single_huge_block:
                            adjusted_score += 0.05
                    
                    if adjusted_score > best_score:
                        best_score = adjusted_score
                        best_params = params
                        best_blocks = blocks
                        best_metrics = metrics
                    
                    if best_score >= early_stop:
                        break
                
                except Exception as e:
                    continue
            
            if best_score >= early_stop:
                break
        
        # Fallback на дефолтные параметры
        if best_params is None or best_score < CONFIG["optimization"]["min_acceptable_score"]:
            default_cfg = CONFIG["default_cv_params"]
            best_params = CVParams(
                min_threshold=default_cfg["min_threshold"],
                max_threshold=default_cfg["max_threshold"],
                ksize_width=default_cfg["ksize_width"],
                ksize_height=default_cfg["ksize_height"],
                dilate_iterations=default_cfg["dilate_iterations"],
                min_intersection_score=default_cfg["min_intersection_score"],
                strategy_name="default_fallback"
            )
            best_blocks = self.cv_detector.detect_blocks(best_params)
            self._assign_elements_to_blocks(elements, best_blocks, best_params.min_intersection_score)
            groups, orphans = self._quick_group(elements, best_blocks)
            best_metrics = QualityAssessor.assess(
                groups, orphans, len(elements),
                len(best_blocks), self.slide_area
            )
        
        # Сохраняем финальный результат
        if CONFIG["debug"]["save_contours"]:
            self.cv_detector.detect_blocks(
                best_params,
                debug_save=True,
                debug_prefix=f"slide_{slide_index:03d}_FINAL"
            )
        
        return best_params, best_blocks, best_metrics
    
    def _generate_params(self, ranges: Dict, strategy_name: str) -> CVParams:
        return CVParams(
            min_threshold=random.randint(*ranges["min_threshold"]),
            max_threshold=random.randint(*ranges["max_threshold"]),
            ksize_width=random.randint(*ranges["ksize_width"]),
            ksize_height=random.randint(*ranges["ksize_height"]),
            dilate_iterations=random.randint(*ranges["dilate_iterations"]),
            min_intersection_score=round(random.uniform(*ranges["min_intersection_score"]), 2),
            strategy_name=strategy_name
        )
    
    def _assign_elements_to_blocks(self, elements: List[LayoutElement],
                                   blocks: List[CVBlock],
                                   min_intersection: float) -> None:
        """Привязывает элементы к блокам"""
        for elem in elements:
            elem.cv_block_id = None
        for block in blocks:
            block.elements = []
        
        for elem in elements:
            best_block = None
            best_score = 0
            
            for block in blocks:
                score = self._intersection_score(elem.bbox, block.bbox)
                if score > min_intersection and score > best_score:
                    best_score = score
                    best_block = block
            
            if best_block:
                elem.cv_block_id = best_block.block_id
                best_block.elements.append(elem)
    
    def _intersection_score(self, boxA: Tuple, boxB: Tuple) -> float:
        xA = max(boxA[0], boxB[0])
        yA = max(boxA[1], boxB[1])
        xB = min(boxA[2], boxB[2])
        yB = min(boxA[3], boxB[3])
        
        inter = max(0, xB - xA) * max(0, yB - yA)
        if inter == 0:
            return 0
        
        areaA = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
        return inter / areaA if areaA > 0 else 0
    
    def _quick_group(self, elements: List[LayoutElement],
                     blocks: List[CVBlock]) -> Tuple[List[ContentGroup], List[LayoutElement]]:
        """Быстрая группировка для оценки качества"""
        groups = []
        used = set()
        
        for block in blocks:
            if block.elements:
                group = ContentGroup(
                    elements=list(block.elements),
                    cv_block_ids=[block.block_id]
                )
                
                visuals = [e for e in block.elements if e.is_visual]
                headers = [e for e in block.elements if e.is_header_like]
                
                if visuals:
                    group.visual_content = visuals[0]
                    group.group_type = "chart_block" if visuals[0].role == ElementRole.CHART else "table_block"
                if headers:
                    group.header = min(headers, key=lambda h: h.bbox[1])
                
                groups.append(group)
                used.update(id(e) for e in block.elements)
        
        orphans = [e for e in elements if id(e) not in used]
        
        return groups, orphans


# ==========================================
# ОБЪЕДИНИТЕЛЬ БЛОКОВ
# ==========================================

class BlockMerger:
    """
    Объединяет логически связанные CV-блоки.
    Например: заголовок в одном блоке → график в другом блоке.
    """
    
    def __init__(self, slide_width: int, slide_height: int):
        self.slide_width = slide_width
        self.slide_height = slide_height
    
    def merge_related_blocks(self, blocks: List[CVBlock], 
                              elements: List[LayoutElement]) -> List[CVBlock]:
        """
        Объединяет блоки, которые логически связаны.
        """
        if len(blocks) <= 1:
            return blocks
        
        merged_blocks = list(blocks)
        merge_pairs = []
        
        # Ищем пары для объединения
        for i, block1 in enumerate(merged_blocks):
            if block1.merged_with is not None:
                continue
            
            for j, block2 in enumerate(merged_blocks):
                if i >= j or block2.merged_with is not None:
                    continue
                
                # Проверяем, нужно ли объединить
                if self._should_merge(block1, block2, elements):
                    merge_pairs.append((i, j))
        
        # Выполняем объединения
        for i, j in merge_pairs:
            block1, block2 = merged_blocks[i], merged_blocks[j]
            
            # Объединяем в block1
            new_bbox = (
                min(block1.bbox[0], block2.bbox[0]),
                min(block1.bbox[1], block2.bbox[1]),
                max(block1.bbox[2], block2.bbox[2]),
                max(block1.bbox[3], block2.bbox[3])
            )
            block1.bbox = new_bbox
            block1.elements.extend(block2.elements)
            block2.merged_with = block1.block_id
            block2.elements = []
        
        # Возвращаем только не-объединённые блоки
        return [b for b in merged_blocks if b.merged_with is None and b.elements]
    
    def _should_merge(self, block1: CVBlock, block2: CVBlock,
                      elements: List[LayoutElement]) -> bool:
        """
        Определяет, нужно ли объединить два блока.
        """
        # Проверяем расстояние
        gap = self._vertical_gap(block1, block2)
        max_gap = CONFIG["grouping"]["merge_blocks_max_gap"]
        
        if gap > max_gap:
            return False
        
        # Проверяем выравнивание
        if not self._are_aligned(block1, block2):
            return False
        
        # Проверяем контент
        block1_has_title = any(e.is_header_like for e in block1.elements)
        block1_has_visual = any(e.is_visual for e in block1.elements)
        block2_has_title = any(e.is_header_like for e in block2.elements)
        block2_has_visual = any(e.is_visual for e in block2.elements)
        
        # Заголовок + график = объединить
        if block1_has_title and not block1_has_visual and block2_has_visual and not block2_has_title:
            if block1.center_y < block2.center_y:  # Заголовок выше
                return True
        
        if block2_has_title and not block2_has_visual and block1_has_visual and not block1_has_title:
            if block2.center_y < block1.center_y:  # Заголовок выше
                return True
        
        return False
    
    def _vertical_gap(self, block1: CVBlock, block2: CVBlock) -> float:
        """Вертикальное расстояние между блоками"""
        if block1.center_y < block2.center_y:
            return block2.bbox[1] - block1.bbox[3]
        else:
            return block1.bbox[1] - block2.bbox[3]
    
    def _are_aligned(self, block1: CVBlock, block2: CVBlock) -> bool:
        """Проверка выравнивания блоков"""
        # Горизонтальное перекрытие
        overlap = min(block1.bbox[2], block2.bbox[2]) - max(block1.bbox[0], block2.bbox[0])
        min_width = min(block1.width, block2.width)
        
        if min_width > 0 and overlap > min_width * 0.3:
            return True
        
        # Выравнивание по центру
        if abs(block1.center_x - block2.center_x) < min_width * 0.4:
            return True
        
        return False


# ==========================================
# ГРУППИРОВЩИК
# ==========================================

class HybridGrouper:
    """Гибридная группировка элементов"""
    
    def __init__(self, slide, image_path: str, prs, slide_index: int):
        self.slide = slide
        self.slide_index = slide_index
        
        sw = prs.slide_width if prs.slide_width > 0 else 9144000
        sh = prs.slide_height if prs.slide_height > 0 else 6858000
        
        self.cv_detector = CVBlockDetector(image_path)
        self.scale_x = self.cv_detector.w / sw
        self.scale_y = self.cv_detector.h / sh
        self.slide_width = self.cv_detector.w
        self.slide_height = self.cv_detector.h
        self.slide_area = self.slide_width * self.slide_height
        
        self.classifier = RoleClassifier(self.slide_width, self.slide_height)
        self.optimizer = ParameterOptimizer(self.cv_detector, self.slide_area)
        self.block_merger = BlockMerger(self.slide_width, self.slide_height)
    
    def emu_to_pixels(self, shape) -> Tuple[int, int, int, int]:
        x = int(shape.left * self.scale_x)
        y = int(shape.top * self.scale_y)
        w = int(shape.width * self.scale_x)
        h = int(shape.height * self.scale_y)
        return (x, y, x + w, y + h)
    
    def process(self) -> Tuple[List[ContentGroup], QualityMetrics, CVParams]:
        """Полный цикл обработки слайда"""
        
        # 1. Извлечение элементов
        elements = self._extract_elements()
        
        if not elements:
            return [], QualityMetrics(), CVParams()
        
        # 2. Оптимизация CV-параметров
        best_params, cv_blocks, initial_metrics = self.optimizer.optimize(
            elements, self.slide_index
        )
        
        # 3. Объединение логически связанных блоков
        cv_blocks = self.block_merger.merge_related_blocks(cv_blocks, elements)
        
        # Переназначаем элементы после объединения
        self._reassign_elements_to_blocks(elements, cv_blocks, best_params.min_intersection_score)
        
        # 4. Классификация ролей
        self.classifier.classify_all(elements, cv_blocks)
        
        # 5. Группировка
        groups, orphans = self._build_groups(elements, cv_blocks)
        
        # 6. Постобработка
        groups = self._refine_groups(groups, orphans, elements)
        
        # 7. Финальные метрики
        final_metrics = QualityAssessor.assess(
            groups, orphans, len(elements),
            len(cv_blocks), self.slide_area
        )
        
        return groups, final_metrics, best_params
    
    def _extract_elements(self) -> List[LayoutElement]:
        """Извлечение элементов"""
        elements = []
        
        def process_shape(shape, native_group_id=None):
            if isinstance(shape, GroupShape):
                new_group_id = id(shape)
                for child in shape.shapes:
                    process_shape(child, new_group_id)
                return
            
            bbox = self.emu_to_pixels(shape)
            if bbox[2] - bbox[0] < 10 or bbox[3] - bbox[1] < 10:
                return
            
            text = ""
            if hasattr(shape, 'text'):
                text = shape.text.strip()
            
            role = ElementRole.UNKNOWN
            try:
                if hasattr(shape, 'has_chart') and shape.has_chart:
                    role = ElementRole.CHART
                elif hasattr(shape, 'has_table') and shape.has_table:
                    role = ElementRole.TABLE
            except:
                pass
            
            formatting = FormattingAnalyzer.analyze(shape)
            
            elements.append(LayoutElement(
                shape=shape,
                role=role,
                bbox=bbox,
                text=text,
                formatting=formatting,
                native_group_id=native_group_id
            ))
        
        for shape in self.slide.shapes:
            process_shape(shape)
        
        return elements
    
    def _reassign_elements_to_blocks(self, elements: List[LayoutElement],
                                      blocks: List[CVBlock],
                                      min_intersection: float) -> None:
        """Переназначает элементы к блокам после объединения"""
        for elem in elements:
            elem.cv_block_id = None
        for block in blocks:
            block.elements = []
        
        for elem in elements:
            best_block = None
            best_score = 0
            
            for block in blocks:
                score = self._intersection_score(elem.bbox, block.bbox)
                if score > min_intersection and score > best_score:
                    best_score = score
                    best_block = block
            
            if best_block:
                elem.cv_block_id = best_block.block_id
                best_block.elements.append(elem)
    
    def _intersection_score(self, boxA: Tuple, boxB: Tuple) -> float:
        xA = max(boxA[0], boxB[0])
        yA = max(boxA[1], boxB[1])
        xB = min(boxA[2], boxB[2])
        yB = min(boxA[3], boxB[3])
        
        inter = max(0, xB - xA) * max(0, yB - yA)
        if inter == 0:
            return 0
        
        areaA = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
        return inter / areaA if areaA > 0 else 0
    
    def _build_groups(self, elements: List[LayoutElement],
                      cv_blocks: List[CVBlock]) -> Tuple[List[ContentGroup], List[LayoutElement]]:
        """Построение групп"""
        groups = []
        used = set()
        
        # Приоритет 1: Нативные группы PowerPoint
        native_groups = defaultdict(list)
        for elem in elements:
            if elem.native_group_id is not None:
                native_groups[elem.native_group_id].append(elem)
        
        for group_id, group_elems in native_groups.items():
            group = self._create_group(group_elems)
            group.native_group_id = group_id
            groups.append(group)
            used.update(id(e) for e in group_elems)
        
        # Приоритет 2: CV-блоки
        for cv_block in cv_blocks:
            block_elems = [e for e in cv_block.elements if id(e) not in used]
            if not block_elems:
                continue
            
            # Разделяем блок если в нём несколько графиков
            subgroups = self._split_cv_block(block_elems)
            
            for sg_elems in subgroups:
                group = self._create_group(sg_elems)
                group.cv_block_ids = [cv_block.block_id]
                groups.append(group)
                used.update(id(e) for e in sg_elems)
        
        # Приоритет 3: Связывание orphans
        orphans = [e for e in elements if id(e) not in used]
        
        # Связываем заголовки секций с подпунктами
        section_groups = self._group_sections(orphans, used)
        groups.extend(section_groups)
        
        # Связываем одинокие заголовки с графиками
        self._link_orphan_titles(groups, orphans, used)
        
        final_orphans = [e for e in orphans if id(e) not in used]
        
        return groups, final_orphans
    
    def _split_cv_block(self, elements: List[LayoutElement]) -> List[List[LayoutElement]]:
        """Разделение CV-блока на подгруппы если в нём несколько графиков"""
        visuals = [e for e in elements if e.is_visual]
        
        if len(visuals) <= 1:
            return [elements]
        
        subgroups = []
        assigned = set()
        
        visuals.sort(key=lambda e: (e.bbox[1], e.bbox[0]))
        
        for visual in visuals:
            sg = [visual]
            assigned.add(id(visual))
            
            # Ищем заголовок
            title = self._find_title_for(visual, elements, assigned)
            if title:
                sg.insert(0, title)
                assigned.add(id(title))
            
            # Ищем легенды
            legends = self._find_legends_for(visual, elements, assigned)
            sg.extend(legends)
            assigned.update(id(l) for l in legends)
            
            subgroups.append(sg)
        
        # Распределяем остальное
        remaining = [e for e in elements if id(e) not in assigned]
        if remaining and subgroups:
            for elem in remaining:
                closest = min(subgroups, key=lambda sg: min(
                    abs(elem.center_y - e.center_y) for e in sg if e.is_visual
                ) if any(e.is_visual for e in sg) else float('inf'))
                closest.append(elem)
        elif remaining:
            subgroups.append(remaining)
        
        return subgroups
    
    def _find_title_for(self, visual: LayoutElement,
                        candidates: List[LayoutElement],
                        used: Set[int]) -> Optional[LayoutElement]:
        """Поиск заголовка для визуального элемента"""
        best = None
        best_score = 0
        
        for elem in candidates:
            if id(elem) in used or elem.is_visual:
                continue
            
            # Должен быть ВЫШЕ
            if elem.bbox[3] > visual.bbox[1]:
                continue
            
            distance = visual.bbox[1] - elem.bbox[3]
            if distance > CONFIG["grouping"]["max_title_distance"]:
                continue
            
            score = self._title_score(elem, visual, distance)
            
            if score > best_score:
                best_score = score
                best = elem
        
        return best if best_score > 0.28 else None
    
    def _title_score(self, title: LayoutElement,
                     visual: LayoutElement,
                     distance: float) -> float:
        """Оценка соответствия заголовка"""
        score = 0.0
        
        if distance < 20:
            score += 0.38
        elif distance < 45:
            score += 0.28
        elif distance < 70:
            score += 0.15
        
        if self.classifier._is_aligned(title, visual):
            score += 0.25
        
        if title.formatting.importance_score > 0.12:
            score += 0.18
        
        if abs(title.center_x - visual.center_x) < visual.width * 0.25:
            score += 0.19
        
        return min(1.0, score)
    
    def _find_legends_for(self, visual: LayoutElement,
                          candidates: List[LayoutElement],
                          used: Set[int]) -> List[LayoutElement]:
        """Поиск легенд"""
        legends = []
        cfg = CONFIG["grouping"]
        
        for elem in candidates:
            if id(elem) in used or elem.is_visual:
                continue
            if elem.role in (ElementRole.CONTENT_TITLE, ElementRole.SECTION_HEADER, ElementRole.SLIDE_TITLE):
                continue
            
            # Справа
            if (elem.bbox[0] > visual.bbox[2] - 30 and
                elem.bbox[0] < visual.bbox[2] + cfg["max_legend_distance_x"] and
                visual.bbox[1] - 30 < elem.center_y < visual.bbox[3] + 30):
                legends.append(elem)
                continue
            
            # Снизу близко
            if (elem.bbox[1] > visual.bbox[3] and
                elem.bbox[1] < visual.bbox[3] + cfg["max_legend_distance_y"] and
                abs(elem.center_x - visual.center_x) < visual.width * 0.5 and
                elem.formatting.importance_score < 0.18):
                legends.append(elem)
        
        return legends
    
    def _group_sections(self, orphans: List[LayoutElement],
                        used: Set[int]) -> List[ContentGroup]:
        """Группировка заголовков секций с подпунктами (для текстовых слайдов)"""
        groups = []
        
        section_headers = [
            e for e in orphans
            if e.role == ElementRole.SECTION_HEADER and id(e) not in used
        ]
        
        for header in section_headers:
            group_elems = [header]
            used.add(id(header))
            
            for elem in orphans:
                if id(elem) in used:
                    continue
                if elem.bbox[1] <= header.bbox[3]:
                    continue
                if not self.classifier._is_aligned(header, elem):
                    continue
                if elem.formatting.importance_score >= header.formatting.importance_score - 0.04:
                    continue
                if elem.bbox[1] - header.bbox[3] > 180:
                    continue
                
                group_elems.append(elem)
                used.add(id(elem))
            
            if group_elems:
                group = self._create_group(group_elems)
                group.header = header
                groups.append(group)
        
        return groups
    
    def _link_orphan_titles(self, groups: List[ContentGroup],
                            orphans: List[LayoutElement],
                            used: Set[int]) -> None:
        """Связывание одиноких заголовков с графиками без заголовков"""
        charts_without_title = [
            g for g in groups
            if g.has_visual and not g.has_header
        ]
        
        potential_titles = [
            e for e in orphans
            if id(e) not in used and
            e.role in (ElementRole.CONTENT_TITLE, ElementRole.BODY_TEXT) and
            e.formatting.importance_score > 0.08
        ]
        
        for group in charts_without_title:
            visual = group.visual_content
            best_title = None
            best_score = 0
            
            for title in potential_titles:
                if id(title) in used:
                    continue
                
                # Должен быть выше
                if title.bbox[3] > visual.bbox[1]:
                    continue
                
                distance = visual.bbox[1] - title.bbox[3]
                if distance > CONFIG["grouping"]["max_title_distance"] * 1.3:
                    continue
                
                score = self._title_score(title, visual, distance)
                
                if score > best_score:
                    best_score = score
                    best_title = title
            
            if best_title and best_score > 0.22:
                group.elements.insert(0, best_title)
                group.header = best_title
                used.add(id(best_title))
    
    def _create_group(self, elements: List[LayoutElement]) -> ContentGroup:
        """Создание группы"""
        group = ContentGroup(elements=elements)
        
        visuals = [e for e in elements if e.is_visual]
        headers = [e for e in elements if e.is_header_like]
        
        if visuals:
            group.visual_content = visuals[0]
            group.group_type = "chart_block" if visuals[0].role == ElementRole.CHART else "table_block"
        elif headers and len(elements) > 1:
            group.group_type = "section_block"
        elif headers:
            group.group_type = "header_only"
        else:
            group.group_type = "text_block"
        
        if headers:
            group.header = min(headers, key=lambda h: h.bbox[1])
        
        return group
    
    def _refine_groups(self, groups: List[ContentGroup],
                       orphans: List[LayoutElement],
                       all_elements: List[LayoutElement]) -> List[ContentGroup]:
        """Финальная доработка групп"""
        
        # Удаляем слишком далёкие элементы
        for group in groups:
            if group.visual_content:
                valid = []
                for elem in group.elements:
                    if elem == group.visual_content or elem == group.header:
                        valid.append(elem)
                    else:
                        dist = self._distance(elem, group.visual_content)
                        if dist < 160:
                            valid.append(elem)
                group.elements = valid
        
        # Добавляем orphans как отдельные группы
        for orphan in orphans:
            groups.append(self._create_group([orphan]))
        
        # Сортировка
        groups.sort(key=lambda g: (g.bbox[1], g.bbox[0]))
        
        # Назначаем reading_order
        for i, group in enumerate(groups):
            for elem in group.elements:
                elem.reading_order = i
        
        return groups
    
    def _distance(self, e1: LayoutElement, e2: LayoutElement) -> float:
        dx = e1.center_x - e2.center_x
        dy = e1.center_y - e2.center_y
        return (dx**2 + dy**2) ** 0.5


# ==========================================
# КОНВЕРТЕР В JSON
# ==========================================

class OutputConverter:
    """Конвертация в JSON-формат"""
    
    @staticmethod
    def convert(groups: List[ContentGroup]) -> List[Dict]:
        result = []
        
        for group in groups:
            data = {
                "type": group.group_type,
                "header": group.header.text if group.header else None,
                "combined_text": "",
                "text_elements": [],
                "charts_data": [],
                "tables_data": []
            }
            
            text_parts = []
            sorted_elems = sorted(group.elements, key=lambda e: e.reading_order)
            
            for elem in sorted_elems:
                if elem == group.header:
                    continue
                
                if elem.role == ElementRole.CHART:
                    data["charts_data"].append(OutputConverter._extract_chart(elem.shape))
                elif elem.role == ElementRole.TABLE:
                    data["tables_data"].append(OutputConverter._extract_table(elem.shape))
                elif elem.text:
                    text_parts.append({
                        "text": elem.text,
                        "role": elem.role.value
                    })
            
            data["text_elements"] = text_parts
            data["combined_text"] = "\n".join(t["text"] for t in text_parts)
            
            result.append(data)
        
        return result
    
    @staticmethod
    def _extract_chart(shape) -> Dict:
        try:
            chart = shape.chart
            data = {"title": "", "series": []}
            
            try:
                if chart.has_title:
                    data["title"] = chart.chart_title.text_frame.text.strip()
            except:
                pass
            
            categories = []
            try:
                if chart.plots and len(chart.plots) > 0:
                    categories = [str(c.label) for c in chart.plots[0].categories]
            except:
                pass
            
            for series in chart.series:
                s = {
                    "legend": series.name or "Series",
                    "values": list(series.values) if series.values else []
                }
                if categories and len(categories) == len(s["values"]):
                    s["mapped_data"] = dict(zip(categories, s["values"]))
                data["series"].append(s)
            
            return data
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    def _extract_table(shape) -> List[List[str]]:
        try:
            return [
                [cell.text_frame.text.strip().replace('\n', ' ') for cell in row.cells]
                for row in shape.table.rows
            ]
        except:
            return []


# ==========================================
# FALLBACK: ЛИНЕЙНЫЙ ПАРСИНГ
# ==========================================

def get_linear_content(slide) -> List[Dict]:
    """Fallback: линейное извлечение контента"""
    
    def extract_from_shapes(shapes):
        results = {"text": [], "charts": [], "tables": []}
        
        for shape in shapes:
            if isinstance(shape, GroupShape):
                sub = extract_from_shapes(shape.shapes)
                results["text"].extend(sub["text"])
                results["charts"].extend(sub["charts"])
                results["tables"].extend(sub["tables"])
                continue
            
            try:
                if hasattr(shape, 'has_chart') and shape.has_chart:
                    results["charts"].append(OutputConverter._extract_chart(shape))
                elif hasattr(shape, 'has_table') and shape.has_table:
                    results["tables"].append(OutputConverter._extract_table(shape))
                elif hasattr(shape, 'text') and shape.text.strip():
                    results["text"].append(shape.text.strip())
            except:
                pass
        
        return results
    
    sorted_shapes = sorted(slide.shapes, key=lambda s: (s.top, s.left))
    content = extract_from_shapes(sorted_shapes)
    
    return [{
        "type": "linear_fallback",
        "combined_text": "\n".join(content["text"]),
        "charts_data": content["charts"],
        "tables_data": content["tables"]
    }]


# ==========================================
# ГЛАВНЫЙ ПАРСЕР
# ==========================================

class PresentationParser:
    """Главный класс парсера презентаций"""
    
    def __init__(self, config: Dict = None):
        if config:
            CONFIG.update(config)
    
    def parse_slide(self, slide, image_path: str, prs, 
                    slide_index: int) -> Dict:
        """Обработка одного слайда"""
        
        try:
            grouper = HybridGrouper(slide, image_path, prs, slide_index)
            groups, metrics, params = grouper.process()
            
            if metrics.score < CONFIG["optimization"]["min_acceptable_score"]:
                return {
                    "slide_number": slide_index + 1,
                    "layout_groups": get_linear_content(slide),
                    "quality_metrics": metrics.to_dict(),
                    "used_parameters": params.to_dict(),
                    "processing_method": "linear_fallback"
                }
            
            return {
                "slide_number": slide_index + 1,
                "layout_groups": OutputConverter.convert(groups),
                "quality_metrics": metrics.to_dict(),
                "used_parameters": params.to_dict(),
                "processing_method": "hybrid_cv_structure"
            }
        
        except Exception as e:
            return {
                "slide_number": slide_index + 1,
                "layout_groups": get_linear_content(slide),
                "quality_metrics": {"score": 0, "error": str(e)},
                "processing_method": "error_fallback"
            }


# ==========================================
# ОСНОВНАЯ ФУНКЦИЯ ПАРСИНГА
# ==========================================

def parse_presentation(pptx_path: str, 
                       image_folder: str,
                       output_json: str) -> List[Dict]:
    """Основная функция парсинга презентации"""
    print(f"Обработка: {pptx_path}")
    
    print("Экспорт изображений слайдов...")
    images = SlideImageExporter.export(pptx_path, image_folder)
    
    if not images:
        raise ValueError("Не удалось экспортировать изображения слайдов")
    
    print(f"Экспортировано {len(images)} изображений")
    
    prs = Presentation(pptx_path)
    parser = PresentationParser()
    
    results = []
    
    for i, slide in enumerate(prs.slides):
        print(f"Обработка слайда {i + 1}/{len(prs.slides)}...")
        
        if i >= len(images):
            print(f"  Предупреждение: нет изображения для слайда {i + 1}")
            result = {
                "slide_number": i + 1,
                "layout_groups": get_linear_content(slide),
                "processing_method": "no_image_fallback"
            }
        else:
            result = parser.parse_slide(slide, images[i], prs, i)
        
        results.append(result)
        
        method = result.get("processing_method", "unknown")
        score = result.get("quality_metrics", {}).get("score", "N/A")
        cv_blocks = result.get("quality_metrics", {}).get("total_cv_blocks", "N/A")
        print(f"  Метод: {method}, Оценка: {score}, CV-блоков: {cv_blocks}")
    
    print(f"Сохранение результатов в {output_json}...")
    with open(output_json, "w", encoding="utf-8") as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    # Статистика
    methods = defaultdict(int)
    scores = []
    
    for r in results:
        methods[r.get("processing_method", "unknown")] += 1
        if "quality_metrics" in r and isinstance(r["quality_metrics"], dict):
            if "score" in r["quality_metrics"]:
                scores.append(r["quality_metrics"]["score"])
    
    print("\n=== Статистика ===")
    print(f"Всего слайдов: {len(results)}")
    for method, count in methods.items():
        print(f"  {method}: {count}")
    if scores:
        print(f"Средняя оценка: {sum(scores) / len(scores):.3f}")
    
    print("Готово!")
    
    return results


# ==========================================
# ТОЧКА ВХОДА
# ==========================================

if __name__ == "__main__":
    PPTX_FILE = r""  # Укажите путь к файлу презентации
    IMG_FOLDER = "temp_images"
    JSON_OUTPUT = "final_output.json"
    
    result = parse_presentation(PPTX_FILE, IMG_FOLDER, JSON_OUTPUT)
