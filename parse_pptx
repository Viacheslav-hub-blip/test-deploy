"""
Гибридный парсер PPTX с динамической адаптацией параметров CV.

Особенности:
1. CV-детекция блоков с оптимизацией параметров
2. Структурный анализ форматирования (не длины текста)
3. Минимизация orphans через итеративную оптимизацию
4. Поддержка текстовых слайдов с колонками
5. Учёт нативных групп PowerPoint
"""

import cv2
import numpy as np
import json
import os
import random
import platform
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple, Set, Any
from enum import Enum
from collections import defaultdict

from pptx import Presentation
from pptx.shapes.group import GroupShape
from pptx.shapes.graphfrm import GraphicFrame
from pptx.enum.shapes import PP_PLACEHOLDER


# ==========================================
# КОНФИГУРАЦИЯ
# ==========================================

CONFIG = {
    # Дефолтные параметры CV-детекции
    "default_cv_params": {
        "min_threshold": 20,
        "max_threshold": 150,
        "ksize_width": 4,
        "ksize_height": 38,
        "dilate_iterations": 6,
        "min_intersection_score": 0.15
    },
    
    # Стратегии оптимизации CV-параметров
    "cv_strategies": {
        "balanced": {
            "min_threshold": (20, 40),
            "max_threshold": (120, 180),
            "ksize_width": (3, 6),
            "ksize_height": (25, 45),
            "dilate_iterations": (4, 7),
            "min_intersection_score": (0.12, 0.22)
        },
        "wide_merge": {
            "min_threshold": (10, 25),
            "max_threshold": (70, 130),
            "ksize_width": (5, 12),
            "ksize_height": (35, 60),
            "dilate_iterations": (5, 9),
            "min_intersection_score": (0.08, 0.18)
        },
        "vertical_focus": {
            "min_threshold": (15, 35),
            "max_threshold": (90, 160),
            "ksize_width": (2, 5),
            "ksize_height": (45, 80),
            "dilate_iterations": (5, 10),
            "min_intersection_score": (0.10, 0.25)
        },
        "aggressive": {
            "min_threshold": (5, 20),
            "max_threshold": (50, 100),
            "ksize_width": (8, 18),
            "ksize_height": (40, 70),
            "dilate_iterations": (6, 12),
            "min_intersection_score": (0.05, 0.15)
        },
        "conservative": {
            "min_threshold": (30, 50),
            "max_threshold": (140, 200),
            "ksize_width": (2, 4),
            "ksize_height": (20, 35),
            "dilate_iterations": (3, 5),
            "min_intersection_score": (0.18, 0.30)
        }
    },
    
    # Параметры оптимизации
    "optimization": {
        "iterations_per_strategy": 5,
        "min_acceptable_score": 0.5,
        "early_stop_score": 0.85,
    },
    
    # Параметры оценки качества
    "quality": {
        "target_orphan_ratio": 0.1,
        "target_block_range": (2, 20),
        "bonus_chart_with_title": 0.15,
        "bonus_multi_element_block": 0.1,
        "penalty_isolated_title": 0.2,
        "penalty_chart_without_title": 0.15,
    },
    
    # Параметры группировки
    "grouping": {
        "max_title_distance": 80,
        "max_legend_distance_x": 120,
        "max_legend_distance_y": 50,
        "column_gap_ratio": 0.06,
    },
    
    # Классификация
    "classification": {
        "header_zone_ratio": 0.18,
        "footer_zone_ratio": 0.85,
        "min_importance_for_header": 0.22,
    },
    
    # Debug
    "debug": {
        "save_contours": True,
        "output_dir": "debug_contours"
    }
}


# ==========================================
# ТИПЫ И СТРУКТУРЫ
# ==========================================

class ElementRole(Enum):
    SLIDE_TITLE = "slide_title"
    SECTION_HEADER = "section_header"
    CONTENT_TITLE = "content_title"
    BODY_TEXT = "body_text"
    BULLET_POINT = "bullet_point"
    CHART = "chart"
    TABLE = "table"
    LEGEND = "legend"
    FOOTNOTE = "footnote"
    IMAGE = "image"
    UNKNOWN = "unknown"


class LayoutType(Enum):
    SINGLE_COLUMN = "single_column"
    TWO_COLUMNS = "two_columns"
    MULTI_COLUMNS = "multi_columns"
    GRID = "grid"
    MIXED = "mixed"
    TITLE_ONLY = "title_only"
    EMPTY = "empty"


@dataclass
class CVParams:
    """Параметры CV-детекции"""
    min_threshold: int = 20
    max_threshold: int = 150
    ksize_width: int = 4
    ksize_height: int = 38
    dilate_iterations: int = 6
    min_intersection_score: float = 0.15
    strategy_name: str = "default"
    
    def to_dict(self) -> Dict:
        return {
            "min_threshold": self.min_threshold,
            "max_threshold": self.max_threshold,
            "ksize_width": self.ksize_width,
            "ksize_height": self.ksize_height,
            "dilate_iterations": self.dilate_iterations,
            "min_intersection_score": self.min_intersection_score,
            "strategy": self.strategy_name
        }


@dataclass
class TextFormatting:
    """Форматирование текста"""
    font_size: Optional[float] = None
    is_bold: bool = False
    is_title_placeholder: bool = False
    indent_level: int = 0
    has_bullet: bool = False
    
    @property
    def importance_score(self) -> float:
        score = 0.0
        if self.is_title_placeholder:
            score += 0.5
        if self.font_size:
            score += min(0.3, max(0, (self.font_size - 12) / 40))
        if self.is_bold:
            score += 0.12
        if not self.has_bullet:
            score += 0.04
        if self.indent_level == 0:
            score += 0.04
        return min(1.0, score)


@dataclass
class LayoutElement:
    """Элемент слайда"""
    shape: Any
    role: ElementRole
    bbox: Tuple[int, int, int, int]
    text: str = ""
    formatting: TextFormatting = field(default_factory=TextFormatting)
    native_group_id: Optional[int] = None
    cv_block_id: Optional[int] = None
    column_id: Optional[int] = None
    reading_order: int = 0
    
    @property
    def center_x(self) -> float:
        return (self.bbox[0] + self.bbox[2]) / 2
    
    @property
    def center_y(self) -> float:
        return (self.bbox[1] + self.bbox[3]) / 2
    
    @property
    def width(self) -> int:
        return self.bbox[2] - self.bbox[0]
    
    @property
    def height(self) -> int:
        return self.bbox[3] - self.bbox[1]
    
    @property
    def is_visual(self) -> bool:
        return self.role in (ElementRole.CHART, ElementRole.TABLE)
    
    @property
    def is_header_like(self) -> bool:
        return self.role in (
            ElementRole.SLIDE_TITLE,
            ElementRole.SECTION_HEADER,
            ElementRole.CONTENT_TITLE
        )


@dataclass
class CVBlock:
    """Блок от CV-детекции"""
    bbox: Tuple[int, int, int, int]
    block_id: int
    elements: List[LayoutElement] = field(default_factory=list)


@dataclass
class ContentGroup:
    """Группа связанного контента"""
    elements: List[LayoutElement] = field(default_factory=list)
    group_type: str = "unknown"
    header: Optional[LayoutElement] = None
    visual_content: Optional[LayoutElement] = None
    cv_block_id: Optional[int] = None
    native_group_id: Optional[int] = None
    column_id: Optional[int] = None
    
    @property
    def bbox(self) -> Tuple[int, int, int, int]:
        if not self.elements:
            return (0, 0, 0, 0)
        return (
            min(e.bbox[0] for e in self.elements),
            min(e.bbox[1] for e in self.elements),
            max(e.bbox[2] for e in self.elements),
            max(e.bbox[3] for e in self.elements)
        )
    
    @property
    def has_visual(self) -> bool:
        return self.visual_content is not None
    
    @property
    def has_header(self) -> bool:
        return self.header is not None


@dataclass
class QualityMetrics:
    """Метрики качества группировки"""
    total_elements: int = 0
    total_groups: int = 0
    orphan_count: int = 0
    orphan_ratio: float = 0.0
    charts_with_title: int = 0
    charts_without_title: int = 0
    isolated_titles: int = 0
    multi_element_groups: int = 0
    score: float = 0.0
    
    def to_dict(self) -> Dict:
        return {
            "total_elements": self.total_elements,
            "total_groups": self.total_groups,
            "orphan_count": self.orphan_count,
            "orphan_ratio": round(self.orphan_ratio, 3),
            "charts_with_title": self.charts_with_title,
            "charts_without_title": self.charts_without_title,
            "isolated_titles": self.isolated_titles,
            "multi_element_groups": self.multi_element_groups,
            "score": round(self.score, 3)
        }


# ==========================================
# КЛАСС ДЛЯ ГЕНЕРАЦИИ ИЗОБРАЖЕНИЙ
# ==========================================

class SlideImageExporter:
    @staticmethod
    def export(pptx_path: str, output_folder: str, dpi: int = 96) -> list[str]:
        """
        Экспорт слайдов презентации в изображения.

        Args:
            pptx_path: Путь к файлу презентации
            output_folder: Папка для сохранения изображений
            dpi: Разрешение изображений (актуально для Linux/OSX)

        Returns:
            Список путей к сохраненным изображениям
        """
        abs_pptx = os.path.abspath(pptx_path)
        abs_output = os.path.abspath(output_folder)

        if not os.path.exists(abs_pptx):
            raise FileNotFoundError(f"Файл презентации не найден: {abs_pptx}")

        if not os.path.exists(abs_output):
            os.makedirs(abs_output, exist_ok=True)

        os_type = platform.system()

        if os_type == "Windows":
            return SlideImageExporter._export_windows(abs_pptx, abs_output)
        elif os_type in ["Linux", "Darwin"]:
            return SlideImageExporter._export_linux(abs_pptx, abs_output, dpi)
        else:
            raise NotImplementedError(f"Неподдерживаемая ОС: {os_type}")

    @staticmethod
    def _export_windows(pptx_path: str, output_folder: str) -> list[str]:
        """Экспорт для Windows через win32com"""
        try:
            import win32com.client
        except ImportError:
            raise ImportError(
                "Для работы под Windows требуется библиотека pywin32. "
                "Установите её: pip install pywin32"
            )

        paths = []
        powerpoint = None
        pres = None

        try:
            powerpoint = win32com.client.Dispatch("PowerPoint.Application")
            pres = powerpoint.Presentations.Open(pptx_path, WithWindow=False)

            for i, slide in enumerate(pres.Slides):
                fname = os.path.join(output_folder, f"slide_{i + 1}.jpg")
                if os.path.exists(fname):
                    os.remove(fname)
                slide.Export(fname, "JPG", 0, 0)
                paths.append(fname)

            if pres:
                pres.Close()
            if powerpoint:
                powerpoint.Quit()

            return paths

        except Exception as e:
            print(f"Ошибка при экспорте в Windows: {e}")
            return []
        finally:
            try:
                if pres:
                    del pres
                if powerpoint:
                    del powerpoint
            except:
                pass

    @staticmethod
    def _export_linux(pptx_path: str, output_folder: str, dpi: int = 96) -> list[str]:
        """Экспорт для Linux/macOS через LibreOffice"""
        # Пробуем LibreOffice
        result = SlideImageExporter.export_via_libreoffice(pptx_path, output_folder, dpi)
        if result:
            return result
        
        print("Внимание: не удалось экспортировать слайды.")
        print("Рассмотрите альтернативные варианты для Linux:")
        print("1. Установите LibreOffice: sudo apt-get install libreoffice")
        print("2. Используйте cloud-конвертацию")
        return []

    @staticmethod
    def export_via_libreoffice(pptx_path: str, output_folder: str, dpi: int = 96) -> list[str]:
        """
        Альтернативный метод для Linux через LibreOffice
        Требует установленного LibreOffice
        """
        import subprocess

        abs_pptx = os.path.abspath(pptx_path)
        abs_output = os.path.abspath(output_folder)

        if not os.path.exists(abs_output):
            os.makedirs(abs_output, exist_ok=True)

        paths = []

        try:
            cmd = [
                'libreoffice', '--headless', '--convert-to', 'jpg',
                '--outdir', abs_output, abs_pptx
            ]

            result = subprocess.run(cmd, capture_output=True, text=True)

            if result.returncode != 0:
                print(f"Ошибка LibreOffice: {result.stderr}")
                return []

            base_name = os.path.splitext(os.path.basename(abs_pptx))[0]

            for i in range(1, 100):
                fname = os.path.join(abs_output, f"{base_name}_{i}.jpg")
                if os.path.exists(fname):
                    paths.append(fname)
                else:
                    alt_fname = os.path.join(abs_output, f"slide_{i}.jpg")
                    if os.path.exists(alt_fname):
                        paths.append(alt_fname)
                    else:
                        break

            return paths

        except FileNotFoundError:
            print("LibreOffice не найден. Установите его:")
            print("Ubuntu/Debian: sudo apt-get install libreoffice")
            print("Fedora: sudo dnf install libreoffice")
            print("macOS: brew install libreoffice")
            return []
        except Exception as e:
            print(f"Ошибка при конвертации через LibreOffice: {e}")
            return []


# ==========================================
# CV ДЕТЕКТОР
# ==========================================

class CVBlockDetector:
    """Детекция блоков через OpenCV"""
    
    def __init__(self, image_path: str):
        self.image_path = image_path
        self.img = cv2.imread(image_path)
        if self.img is None:
            raise ValueError(f"Cannot load image: {image_path}")
        self.h, self.w = self.img.shape[:2]
    
    def detect_blocks(self, params: CVParams, 
                      debug_save: bool = False,
                      debug_prefix: str = "") -> List[CVBlock]:
        """Детекция блоков с заданными параметрами"""
        
        gray = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)
        edges = cv2.Canny(gray, params.min_threshold, params.max_threshold)
        
        kernel = cv2.getStructuringElement(
            cv2.MORPH_RECT,
            (params.ksize_width, params.ksize_height)
        )
        dilated = cv2.dilate(edges, kernel, iterations=params.dilate_iterations)
        
        contours, _ = cv2.findContours(
            dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        
        if debug_save and CONFIG["debug"]["save_contours"]:
            self._save_debug_image(contours, params, debug_prefix)
        
        blocks = []
        for i, cnt in enumerate(contours):
            x, y, w, h = cv2.boundingRect(cnt)
            
            if w < 25 or h < 20:
                continue
            if w > self.w * 0.98 and h > self.h * 0.98:
                continue
            
            blocks.append(CVBlock(
                bbox=(x, y, x + w, y + h),
                block_id=i
            ))
        
        return blocks
    
    def _save_debug_image(self, contours, params: CVParams, prefix: str):
        """Сохраняет изображение с контурами для отладки"""
        debug_dir = CONFIG["debug"]["output_dir"]
        os.makedirs(debug_dir, exist_ok=True)
        
        img_copy = self.img.copy()
        cv2.drawContours(img_copy, contours, -1, (0, 255, 0), 2)
        
        filename = f"{prefix}_{params.strategy_name}.jpg"
        cv2.imwrite(os.path.join(debug_dir, filename), img_copy)
    
    def detect_columns(self) -> List[Tuple[int, int]]:
        """Детекция колонок через вертикальную проекцию"""
        gray = cv2.cvtColor(self.img, cv2.COLOR_BGR2GRAY)
        vertical_proj = np.sum(gray < 245, axis=0)
        
        kernel_size = max(1, self.w // 50)
        if kernel_size > 1:
            vertical_proj = np.convolve(
                vertical_proj, 
                np.ones(kernel_size) / kernel_size, 
                mode='same'
            )
        
        threshold = self.h * 0.05
        gaps = []
        in_gap = False
        gap_start = 0
        
        min_gap_width = int(self.w * CONFIG["grouping"]["column_gap_ratio"])
        
        for x, val in enumerate(vertical_proj):
            if val < threshold and not in_gap:
                in_gap = True
                gap_start = x
            elif val >= threshold and in_gap:
                in_gap = False
                gap_width = x - gap_start
                if gap_width >= min_gap_width:
                    gaps.append((gap_start, x))
        
        columns = []
        prev_end = 0
        
        for gap_start, gap_end in gaps:
            if gap_start > prev_end + 50:
                columns.append((prev_end, gap_start))
            prev_end = gap_end
        
        if prev_end < self.w - 50:
            columns.append((prev_end, self.w))
        
        return columns if columns else [(0, self.w)]


# ==========================================
# АНАЛИЗАТОР ФОРМАТИРОВАНИЯ
# ==========================================

class FormattingAnalyzer:
    """Анализ форматирования текста из PowerPoint"""
    
    TITLE_PLACEHOLDERS = {
        PP_PLACEHOLDER.TITLE,
        PP_PLACEHOLDER.CENTER_TITLE,
        PP_PLACEHOLDER.SUBTITLE,
    }
    
    @staticmethod
    def analyze(shape) -> TextFormatting:
        formatting = TextFormatting()
        
        try:
            if hasattr(shape, 'placeholder_format') and shape.placeholder_format:
                if shape.placeholder_format.type in FormattingAnalyzer.TITLE_PLACEHOLDERS:
                    formatting.is_title_placeholder = True
        except:
            pass
        
        try:
            if hasattr(shape, 'text_frame') and shape.text_frame.paragraphs:
                para = shape.text_frame.paragraphs[0]
                formatting.indent_level = para.level or 0
                
                try:
                    if hasattr(para, 'bullet') and para.bullet:
                        if para.bullet.type is not None:
                            formatting.has_bullet = True
                except:
                    pass
                
                if para.runs:
                    run = para.runs[0]
                    try:
                        if run.font.size:
                            formatting.font_size = run.font.size.pt
                    except:
                        pass
                    try:
                        if run.font.bold:
                            formatting.is_bold = True
                    except:
                        pass
        except:
            pass
        
        return formatting


# ==========================================
# КЛАССИФИКАТОР РОЛЕЙ
# ==========================================

class RoleClassifier:
    """Классификация ролей элементов"""
    
    def __init__(self, slide_width: int, slide_height: int):
        self.slide_width = slide_width
        self.slide_height = slide_height
        cfg = CONFIG["classification"]
        self.header_zone_y = slide_height * cfg["header_zone_ratio"]
        self.footer_zone_y = slide_height * cfg["footer_zone_ratio"]
    
    def classify_all(self, elements: List[LayoutElement], 
                     cv_blocks: List[CVBlock]) -> None:
        """Классифицирует все элементы"""
        for elem in elements:
            if elem.role == ElementRole.UNKNOWN:
                elem.role = self._classify_basic(elem)
        
        for elem in elements:
            if elem.role in (ElementRole.BODY_TEXT, ElementRole.UNKNOWN):
                new_role = self._classify_contextual(elem, elements, cv_blocks)
                if new_role != ElementRole.UNKNOWN:
                    elem.role = new_role
    
    def _classify_basic(self, element: LayoutElement) -> ElementRole:
        """Базовая классификация по типу shape"""
        shape = element.shape
        
        try:
            if hasattr(shape, 'has_chart') and shape.has_chart:
                return ElementRole.CHART
            if hasattr(shape, 'has_table') and shape.has_table:
                return ElementRole.TABLE
        except:
            pass
        
        formatting = element.formatting
        
        if formatting.is_title_placeholder:
            return ElementRole.SLIDE_TITLE
        
        if element.bbox[1] < self.header_zone_y:
            if formatting.importance_score > CONFIG["classification"]["min_importance_for_header"]:
                return ElementRole.SLIDE_TITLE
        
        if element.bbox[1] > self.footer_zone_y:
            if formatting.importance_score < 0.15 and element.height < self.slide_height * 0.05:
                return ElementRole.FOOTNOTE
        
        if formatting.has_bullet or formatting.indent_level > 0:
            return ElementRole.BULLET_POINT
        
        return ElementRole.BODY_TEXT
    
    def _classify_contextual(self, element: LayoutElement,
                             all_elements: List[LayoutElement],
                             cv_blocks: List[CVBlock]) -> ElementRole:
        """Контекстная классификация"""
        
        if self._is_legend(element, all_elements):
            return ElementRole.LEGEND
        
        if self._is_content_title(element, all_elements, cv_blocks):
            return ElementRole.CONTENT_TITLE
        
        if self._is_section_header(element, all_elements):
            return ElementRole.SECTION_HEADER
        
        return ElementRole.UNKNOWN
    
    def _is_legend(self, element: LayoutElement,
                   all_elements: List[LayoutElement]) -> bool:
        """Проверка на легенду"""
        if element.formatting.importance_score > 0.25:
            return False
        
        charts = [e for e in all_elements if e.role == ElementRole.CHART]
        
        for chart in charts:
            same_block = (
                element.cv_block_id is not None and
                chart.cv_block_id is not None and
                element.cv_block_id == chart.cv_block_id
            )
            
            is_right = (
                element.bbox[0] > chart.bbox[2] - 40 and
                element.bbox[0] < chart.bbox[2] + CONFIG["grouping"]["max_legend_distance_x"] and
                chart.bbox[1] - 30 < element.center_y < chart.bbox[3] + 30
            )
            
            is_below = (
                element.bbox[1] > chart.bbox[3] and
                element.bbox[1] < chart.bbox[3] + CONFIG["grouping"]["max_legend_distance_y"] and
                abs(element.center_x - chart.center_x) < chart.width * 0.5 and
                element.formatting.importance_score < 0.18
            )
            
            if same_block and (is_right or is_below):
                return True
            
            if is_right and element.width < chart.width * 0.4:
                return True
        
        return False
    
    def _is_content_title(self, element: LayoutElement,
                          all_elements: List[LayoutElement],
                          cv_blocks: List[CVBlock]) -> bool:
        """Проверка на заголовок графика/таблицы"""
        if element.formatting.importance_score < 0.12:
            return False
        
        visuals_below = [
            e for e in all_elements
            if e.is_visual and
            e.bbox[1] > element.bbox[3] and
            e.bbox[1] - element.bbox[3] < CONFIG["grouping"]["max_title_distance"]
        ]
        
        for visual in visuals_below:
            same_cv = (
                element.cv_block_id is not None and
                visual.cv_block_id is not None and
                element.cv_block_id == visual.cv_block_id
            )
            
            aligned = self._is_aligned(element, visual)
            
            if same_cv or aligned:
                return True
        
        return False
    
    def _is_section_header(self, element: LayoutElement,
                           all_elements: List[LayoutElement]) -> bool:
        """Проверка на заголовок секции"""
        if element.formatting.importance_score < CONFIG["classification"]["min_importance_for_header"]:
            return False
        
        elements_below = [
            e for e in all_elements
            if e.bbox[1] > element.bbox[3] and
            not e.is_visual and
            e.role not in (ElementRole.FOOTNOTE, ElementRole.LEGEND) and
            self._is_aligned(element, e)
        ]
        
        if not elements_below:
            return False
        
        avg_importance = sum(e.formatting.importance_score for e in elements_below) / len(elements_below)
        return element.formatting.importance_score > avg_importance + 0.08
    
    def _is_aligned(self, elem1: LayoutElement, elem2: LayoutElement) -> bool:
        """Проверка выравнивания"""
        overlap = min(elem1.bbox[2], elem2.bbox[2]) - max(elem1.bbox[0], elem2.bbox[0])
        min_width = min(elem1.width, elem2.width)
        if min_width > 0 and overlap > min_width * 0.3:
            return True
        
        if abs(elem1.center_x - elem2.center_x) < min_width * 0.35:
            return True
        
        if abs(elem1.bbox[0] - elem2.bbox[0]) < 35:
            return True
        
        return False


# ==========================================
# ОЦЕНЩИК КАЧЕСТВА
# ==========================================

class QualityAssessor:
    """Оценка качества группировки"""
    
    @staticmethod
    def assess(groups: List[ContentGroup], 
               orphans: List[LayoutElement],
               total_elements: int) -> QualityMetrics:
        """Вычисляет метрики качества"""
        metrics = QualityMetrics()
        metrics.total_elements = total_elements
        metrics.total_groups = len(groups)
        metrics.orphan_count = len(orphans)
        metrics.orphan_ratio = len(orphans) / total_elements if total_elements > 0 else 0
        
        cfg = CONFIG["quality"]
        
        for group in groups:
            if group.has_visual:
                if group.has_header:
                    metrics.charts_with_title += 1
                else:
                    metrics.charts_without_title += 1
            
            if group.has_header and len(group.elements) == 1:
                metrics.isolated_titles += 1
            
            if len(group.elements) > 1:
                metrics.multi_element_groups += 1
        
        score = 1.0
        
        if metrics.orphan_ratio > cfg["target_orphan_ratio"]:
            excess = metrics.orphan_ratio - cfg["target_orphan_ratio"]
            score -= min(0.4, excess * 2)
        
        target_min, target_max = cfg["target_block_range"]
        if metrics.total_groups < target_min:
            score -= 0.15
        elif metrics.total_groups > target_max:
            score -= min(0.2, (metrics.total_groups - target_max) * 0.02)
        
        if metrics.charts_with_title > 0:
            total_charts = metrics.charts_with_title + metrics.charts_without_title
            ratio = metrics.charts_with_title / total_charts
            score += ratio * cfg["bonus_chart_with_title"]
        
        score -= metrics.charts_without_title * cfg["penalty_chart_without_title"]
        score -= metrics.isolated_titles * cfg["penalty_isolated_title"]
        
        if metrics.total_groups > 0:
            multi_ratio = metrics.multi_element_groups / metrics.total_groups
            score += multi_ratio * cfg["bonus_multi_element_block"]
        
        metrics.score = max(0.0, min(1.0, score))
        
        return metrics


# ==========================================
# ОПТИМИЗАТОР ПАРАМЕТРОВ
# ==========================================

class ParameterOptimizer:
    """Динамическая оптимизация параметров CV"""
    
    def __init__(self, cv_detector: CVBlockDetector):
        self.cv_detector = cv_detector
    
    def optimize(self, elements: List[LayoutElement],
                 slide_index: int) -> Tuple[CVParams, List[CVBlock], QualityMetrics]:
        """Находит оптимальные параметры для слайда"""
        best_params = None
        best_blocks = None
        best_metrics = None
        best_score = -1
        
        strategies = CONFIG["cv_strategies"]
        iterations = CONFIG["optimization"]["iterations_per_strategy"]
        early_stop = CONFIG["optimization"]["early_stop_score"]
        
        for strategy_name, ranges in strategies.items():
            for i in range(iterations):
                params = self._generate_params(ranges, strategy_name)
                
                try:
                    blocks = self.cv_detector.detect_blocks(
                        params,
                        debug_save=(i == 0),
                        debug_prefix=f"slide_{slide_index:03d}"
                    )
                    
                    self._assign_elements_to_blocks(elements, blocks, params.min_intersection_score)
                    
                    groups, orphans = self._quick_group(elements, blocks)
                    
                    metrics = QualityAssessor.assess(groups, orphans, len(elements))
                    
                    if metrics.score > best_score:
                        best_score = metrics.score
                        best_params = params
                        best_blocks = blocks
                        best_metrics = metrics
                    
                    if best_score >= early_stop:
                        break
                
                except Exception as e:
                    continue
            
            if best_score >= early_stop:
                break
        
        if best_params is None or best_score < CONFIG["optimization"]["min_acceptable_score"]:
            default_cfg = CONFIG["default_cv_params"]
            best_params = CVParams(
                min_threshold=default_cfg["min_threshold"],
                max_threshold=default_cfg["max_threshold"],
                ksize_width=default_cfg["ksize_width"],
                ksize_height=default_cfg["ksize_height"],
                dilate_iterations=default_cfg["dilate_iterations"],
                min_intersection_score=default_cfg["min_intersection_score"],
                strategy_name="default_fallback"
            )
            best_blocks = self.cv_detector.detect_blocks(best_params)
            self._assign_elements_to_blocks(elements, best_blocks, best_params.min_intersection_score)
            groups, orphans = self._quick_group(elements, best_blocks)
            best_metrics = QualityAssessor.assess(groups, orphans, len(elements))
        
        if CONFIG["debug"]["save_contours"]:
            self.cv_detector.detect_blocks(
                best_params,
                debug_save=True,
                debug_prefix=f"slide_{slide_index:03d}_FINAL"
            )
        
        return best_params, best_blocks, best_metrics
    
    def _generate_params(self, ranges: Dict, strategy_name: str) -> CVParams:
        """Генерирует случайные параметры в заданных диапазонах"""
        return CVParams(
            min_threshold=random.randint(*ranges["min_threshold"]),
            max_threshold=random.randint(*ranges["max_threshold"]),
            ksize_width=random.randint(*ranges["ksize_width"]),
            ksize_height=random.randint(*ranges["ksize_height"]),
            dilate_iterations=random.randint(*ranges["dilate_iterations"]),
            min_intersection_score=round(random.uniform(*ranges["min_intersection_score"]), 2),
            strategy_name=strategy_name
        )
    
    def _assign_elements_to_blocks(self, elements: List[LayoutElement],
                                   blocks: List[CVBlock],
                                   min_intersection: float) -> None:
        """Привязывает элементы к блокам"""
        for elem in elements:
            elem.cv_block_id = None
        for block in blocks:
            block.elements = []
        
        for elem in elements:
            best_block = None
            best_score = 0
            
            for block in blocks:
                score = self._intersection_score(elem.bbox, block.bbox)
                if score > min_intersection and score > best_score:
                    best_score = score
                    best_block = block
            
            if best_block:
                elem.cv_block_id = best_block.block_id
                best_block.elements.append(elem)
    
    def _intersection_score(self, boxA: Tuple, boxB: Tuple) -> float:
        """Доля пересечения boxA с boxB"""
        xA = max(boxA[0], boxB[0])
        yA = max(boxA[1], boxB[1])
        xB = min(boxA[2], boxB[2])
        yB = min(boxA[3], boxB[3])
        
        inter = max(0, xB - xA) * max(0, yB - yA)
        if inter == 0:
            return 0
        
        areaA = (boxA[2] - boxA[0]) * (boxA[3] - boxA[1])
        return inter / areaA if areaA > 0 else 0
    
    def _quick_group(self, elements: List[LayoutElement],
                     blocks: List[CVBlock]) -> Tuple[List[ContentGroup], List[LayoutElement]]:
        """Быстрая группировка для оценки качества"""
        groups = []
        used = set()
        
        for block in blocks:
            if block.elements:
                group = ContentGroup(
                    elements=list(block.elements),
                    cv_block_id=block.block_id
                )
                
                visuals = [e for e in block.elements if e.is_visual]
                headers = [e for e in block.elements if e.is_header_like]
                
                if visuals:
                    group.visual_content = visuals[0]
                    group.group_type = "chart_block" if visuals[0].role == ElementRole.CHART else "table_block"
                if headers:
                    group.header = min(headers, key=lambda h: h.bbox[1])
                
                groups.append(group)
                used.update(id(e) for e in block.elements)
        
        orphans = [e for e in elements if id(e) not in used]
        
        return groups, orphans


# ==========================================
# ГРУППИРОВЩИК
# ==========================================

class HybridGrouper:
    """Гибридная группировка элементов"""
    
    def __init__(self, slide, image_path: str, prs, slide_index: int):
        self.slide = slide
        self.slide_index = slide_index
        
        sw = prs.slide_width if prs.slide_width > 0 else 9144000
        sh = prs.slide_height if prs.slide_height > 0 else 6858000
        
        self.cv_detector = CVBlockDetector(image_path)
        self.scale_x = self.cv_detector.w / sw
        self.scale_y = self.cv_detector.h / sh
        self.slide_width = self.cv_detector.w
        self.slide_height = self.cv_detector.h
        
        self.classifier = RoleClassifier(self.slide_width, self.slide_height)
        self.optimizer = ParameterOptimizer(self.cv_detector)
    
    def emu_to_pixels(self, shape) -> Tuple[int, int, int, int]:
        x = int(shape.left * self.scale_x)
        y = int(shape.top * self.scale_y)
        w = int(shape.width * self.scale_x)
        h = int(shape.height * self.scale_y)
        return (x, y, x + w, y + h)
    
    def process(self) -> Tuple[List[ContentGroup], QualityMetrics, CVParams]:
        """Полный цикл обработки слайда"""
        
        elements = self._extract_elements()
        
        if not elements:
            return [], QualityMetrics(), CVParams()
        
        best_params, cv_blocks, initial_metrics = self.optimizer.optimize(
            elements, self.slide_index
        )
        
        self.classifier.classify_all(elements, cv_blocks)
        
        groups, orphans = self._build_groups(elements, cv_blocks)
        
        groups = self._refine_groups(groups, orphans, elements)
        
        final_metrics = QualityAssessor.assess(groups, orphans, len(elements))
        
        return groups, final_metrics, best_params
    
    def _extract_elements(self) -> List[LayoutElement]:
        """Извлечение элементов"""
        elements = []
        
        def process_shape(shape, native_group_id=None):
            if isinstance(shape, GroupShape):
                new_group_id = id(shape)
                for child in shape.shapes:
                    process_shape(child, new_group_id)
                return
            
            bbox = self.emu_to_pixels(shape)
            if bbox[2] - bbox[0] < 12 or bbox[3] - bbox[1] < 12:
                return
            
            text = ""
            if hasattr(shape, 'text'):
                text = shape.text.strip()
            
            role = ElementRole.UNKNOWN
            try:
                if hasattr(shape, 'has_chart') and shape.has_chart:
                    role = ElementRole.CHART
                elif hasattr(shape, 'has_table') and shape.has_table:
                    role = ElementRole.TABLE
            except:
                pass
            
            formatting = FormattingAnalyzer.analyze(shape)
            
            elements.append(LayoutElement(
                shape=shape,
                role=role,
                bbox=bbox,
                text=text,
                formatting=formatting,
                native_group_id=native_group_id
            ))
        
        for shape in self.slide.shapes:
            process_shape(shape)
        
        return elements
    
    def _build_groups(self, elements: List[LayoutElement],
                      cv_blocks: List[CVBlock]) -> Tuple[List[ContentGroup], List[LayoutElement]]:
        """Построение групп"""
        groups = []
        used = set()
        
        # Приоритет 1: Нативные группы PowerPoint
        native_groups = defaultdict(list)
        for elem in elements:
            if elem.native_group_id is not None:
                native_groups[elem.native_group_id].append(elem)
        
        for group_id, group_elems in native_groups.items():
            group = self._create_group(group_elems)
            group.native_group_id = group_id
            groups.append(group)
            used.update(id(e) for e in group_elems)
        
        # Приоритет 2: CV-блоки
        for cv_block in cv_blocks:
            block_elems = [e for e in cv_block.elements if id(e) not in used]
            if not block_elems:
                continue
            
            subgroups = self._split_cv_block(block_elems)
            
            for sg_elems in subgroups:
                group = self._create_group(sg_elems)
                group.cv_block_id = cv_block.block_id
                groups.append(group)
                used.update(id(e) for e in sg_elems)
        
        # Приоритет 3: Связывание orphans
        orphans = [e for e in elements if id(e) not in used]
        
        section_groups = self._group_sections(orphans, used)
        groups.extend(section_groups)
        
        self._link_orphan_titles(groups, orphans, used)
        
        final_orphans = [e for e in orphans if id(e) not in used]
        
        return groups, final_orphans
    
    def _split_cv_block(self, elements: List[LayoutElement]) -> List[List[LayoutElement]]:
        """Разделение CV-блока на подгруппы"""
        visuals = [e for e in elements if e.is_visual]
        
        if len(visuals) <= 1:
            return [elements]
        
        subgroups = []
        assigned = set()
        
        visuals.sort(key=lambda e: (e.bbox[1], e.bbox[0]))
        
        for visual in visuals:
            sg = [visual]
            assigned.add(id(visual))
            
            title = self._find_title_for(visual, elements, assigned)
            if title:
                sg.insert(0, title)
                assigned.add(id(title))
            
            legends = self._find_legends_for(visual, elements, assigned)
            sg.extend(legends)
            assigned.update(id(l) for l in legends)
            
            subgroups.append(sg)
        
        remaining = [e for e in elements if id(e) not in assigned]
        if remaining and subgroups:
            for elem in remaining:
                closest = min(subgroups, key=lambda sg: min(
                    abs(elem.center_y - e.center_y) for e in sg if e.is_visual
                ) if any(e.is_visual for e in sg) else float('inf'))
                closest.append(elem)
        elif remaining:
            subgroups.append(remaining)
        
        return subgroups
    
    def _find_title_for(self, visual: LayoutElement,
                        candidates: List[LayoutElement],
                        used: Set[int]) -> Optional[LayoutElement]:
        """Поиск заголовка для визуального элемента"""
        best = None
        best_score = 0
        
        for elem in candidates:
            if id(elem) in used or elem.is_visual:
                continue
            
            if elem.bbox[3] > visual.bbox[1]:
                continue
            
            distance = visual.bbox[1] - elem.bbox[3]
            if distance > CONFIG["grouping"]["max_title_distance"]:
                continue
            
            score = self._title_score(elem, visual, distance)
            
            if score > best_score:
                best_score = score
                best = elem
        
        return best if best_score > 0.3 else None
    
    def _title_score(self, title: LayoutElement,
                     visual: LayoutElement,
                     distance: float) -> float:
        """Оценка соответствия заголовка"""
        score = 0.0
        
        if distance < 25:
            score += 0.35
        elif distance < 50:
            score += 0.25
        elif distance < 80:
            score += 0.12
        
        if self.classifier._is_aligned(title, visual):
            score += 0.25
        
        if title.formatting.importance_score > 0.15:
            score += 0.2
        
        if abs(title.center_x - visual.center_x) < visual.width * 0.25:
            score += 0.2
        
        return min(1.0, score)
    
    def _find_legends_for(self, visual: LayoutElement,
                          candidates: List[LayoutElement],
                          used: Set[int]) -> List[LayoutElement]:
        """Поиск легенд"""
        legends = []
        cfg = CONFIG["grouping"]
        
        for elem in candidates:
            if id(elem) in used or elem.is_visual:
                continue
            if elem.role in (ElementRole.CONTENT_TITLE, ElementRole.SECTION_HEADER, ElementRole.SLIDE_TITLE):
                continue
            
            if (elem.bbox[0] > visual.bbox[2] - 30 and
                elem.bbox[0] < visual.bbox[2] + cfg["max_legend_distance_x"] and
                visual.bbox[1] - 30 < elem.center_y < visual.bbox[3] + 30):
                legends.append(elem)
                continue
            
            if (elem.bbox[1] > visual.bbox[3] and
                elem.bbox[1] < visual.bbox[3] + cfg["max_legend_distance_y"] and
                abs(elem.center_x - visual.center_x) < visual.width * 0.5 and
                elem.formatting.importance_score < 0.18):
                legends.append(elem)
        
        return legends
    
    def _group_sections(self, orphans: List[LayoutElement],
                        used: Set[int]) -> List[ContentGroup]:
        """Группировка заголовков секций с подпунктами"""
        groups = []
        
        section_headers = [
            e for e in orphans
            if e.role == ElementRole.SECTION_HEADER and id(e) not in used
        ]
        
        for header in section_headers:
            group_elems = [header]
            used.add(id(header))
            
            for elem in orphans:
                if id(elem) in used:
                    continue
                if elem.bbox[1] <= header.bbox[3]:
                    continue
                if not self.classifier._is_aligned(header, elem):
                    continue
                if elem.formatting.importance_score >= header.formatting.importance_score - 0.05:
                    continue
                if elem.bbox[1] - header.bbox[3] > 200:
                    continue
                
                group_elems.append(elem)
                used.add(id(elem))
            
            if group_elems:
                group = self._create_group(group_elems)
                group.header = header
                groups.append(group)
        
        return groups
    
    def _link_orphan_titles(self, groups: List[ContentGroup],
                            orphans: List[LayoutElement],
                            used: Set[int]) -> None:
        """Связывание одиноких заголовков с графиками без заголовков"""
        charts_without_title = [
            g for g in groups
            if g.has_visual and not g.has_header
        ]
        
        potential_titles = [
            e for e in orphans
            if id(e) not in used and
            e.role in (ElementRole.CONTENT_TITLE, ElementRole.BODY_TEXT) and
            e.formatting.importance_score > 0.1
        ]
        
        for group in charts_without_title:
            visual = group.visual_content
            best_title = None
            best_score = 0
            
            for title in potential_titles:
                if id(title) in used:
                    continue
                
                if title.bbox[3] > visual.bbox[1]:
                    continue
                
                distance = visual.bbox[1] - title.bbox[3]
                if distance > CONFIG["grouping"]["max_title_distance"] * 1.5:
                    continue
                
                score = self._title_score(title, visual, distance)
                
                if score > best_score:
                    best_score = score
                    best_title = title
            
            if best_title and best_score > 0.25:
                group.elements.insert(0, best_title)
                group.header = best_title
                used.add(id(best_title))
    
    def _create_group(self, elements: List[LayoutElement]) -> ContentGroup:
        """Создание группы"""
        group = ContentGroup(elements=elements)
        
        visuals = [e for e in elements if e.is_visual]
        headers = [e for e in elements if e.is_header_like]
        
        if visuals:
            group.visual_content = visuals[0]
            group.group_type = "chart_block" if visuals[0].role == ElementRole.CHART else "table_block"
        elif headers and len(elements) > 1:
            group.group_type = "section_block"
        elif headers:
            group.group_type = "header_only"
        else:
            group.group_type = "text_block"
        
        if headers:
            group.header = min(headers, key=lambda h: h.bbox[1])
        
        return group
    
    def _refine_groups(self, groups: List[ContentGroup],
                       orphans: List[LayoutElement],
                       all_elements: List[LayoutElement]) -> List[ContentGroup]:
        """Финальная доработка групп"""
        
        for group in groups:
            if group.visual_content:
                valid = []
                for elem in group.elements:
                    if elem == group.visual_content or elem == group.header:
                        valid.append(elem)
                    else:
                        dist = self._distance(elem, group.visual_content)
                        if dist < 180:
                            valid.append(elem)
                group.elements = valid
        
        for orphan in orphans:
            groups.append(self._create_group([orphan]))
        
        groups.sort(key=lambda g: (g.bbox[1], g.bbox[0]))
        
        for i, group in enumerate(groups):
            for elem in group.elements:
                elem.reading_order = i
        
        return groups
    
    def _distance(self, e1: LayoutElement, e2: LayoutElement) -> float:
        dx = e1.center_x - e2.center_x
        dy = e1.center_y - e2.center_y
        return (dx**2 + dy**2) ** 0.5


# ==========================================
# КОНВЕРТЕР В JSON
# ==========================================

class OutputConverter:
    """Конвертация в JSON-формат"""
    
    @staticmethod
    def convert(groups: List[ContentGroup]) -> List[Dict]:
        result = []
        
        for group in groups:
            data = {
                "type": group.group_type,
                "header": group.header.text if group.header else None,
                "combined_text": "",
                "text_elements": [],
                "charts_data": [],
                "tables_data": []
            }
            
            text_parts = []
            sorted_elems = sorted(group.elements, key=lambda e: e.reading_order)
            
            for elem in sorted_elems:
                if elem == group.header:
                    continue
                
                if elem.role == ElementRole.CHART:
                    data["charts_data"].append(OutputConverter._extract_chart(elem.shape))
                elif elem.role == ElementRole.TABLE:
                    data["tables_data"].append(OutputConverter._extract_table(elem.shape))
                elif elem.text:
                    text_parts.append({
                        "text": elem.text,
                        "role": elem.role.value
                    })
            
            data["text_elements"] = text_parts
            data["combined_text"] = "\n".join(t["text"] for t in text_parts)
            
            result.append(data)
        
        return result
    
    @staticmethod
    def _extract_chart(shape) -> Dict:
        try:
            chart = shape.chart
            data = {"title": "", "series": []}
            
            try:
                if chart.has_title:
                    data["title"] = chart.chart_title.text_frame.text.strip()
            except:
                pass
            
            categories = []
            try:
                if chart.plots and len(chart.plots) > 0:
                    categories = [str(c.label) for c in chart.plots[0].categories]
            except:
                pass
            
            for series in chart.series:
                s = {
                    "legend": series.name or "Series",
                    "values": list(series.values) if series.values else []
                }
                if categories and len(categories) == len(s["values"]):
                    s["mapped_data"] = dict(zip(categories, s["values"]))
                data["series"].append(s)
            
            return data
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    def _extract_table(shape) -> List[List[str]]:
        try:
            return [
                [cell.text_frame.text.strip().replace('\n', ' ') for cell in row.cells]
                for row in shape.table.rows
            ]
        except:
            return []


# ==========================================
# FALLBACK: ЛИНЕЙНЫЙ ПАРСИНГ
# ==========================================

def get_linear_content(slide) -> List[Dict]:
    """Fallback: линейное извлечение контента"""
    
    def extract_from_shapes(shapes):
        results = {"text": [], "charts": [], "tables": []}
        
        for shape in shapes:
            if isinstance(shape, GroupShape):
                sub = extract_from_shapes(shape.shapes)
                results["text"].extend(sub["text"])
                results["charts"].extend(sub["charts"])
                results["tables"].extend(sub["tables"])
                continue
            
            try:
                if hasattr(shape, 'has_chart') and shape.has_chart:
                    results["charts"].append(OutputConverter._extract_chart(shape))
                elif hasattr(shape, 'has_table') and shape.has_table:
                    results["tables"].append(OutputConverter._extract_table(shape))
                elif hasattr(shape, 'text') and shape.text.strip():
                    results["text"].append(shape.text.strip())
            except:
                pass
        
        return results
    
    sorted_shapes = sorted(slide.shapes, key=lambda s: (s.top, s.left))
    content = extract_from_shapes(sorted_shapes)
    
    return [{
        "type": "linear_fallback",
        "combined_text": "\n".join(content["text"]),
        "charts_data": content["charts"],
        "tables_data": content["tables"]
    }]


# ==========================================
# ГЛАВНЫЙ ПАРСЕР
# ==========================================

class PresentationParser:
    """Главный класс парсера презентаций"""
    
    def __init__(self, config: Dict = None):
        if config:
            CONFIG.update(config)
    
    def parse_slide(self, slide, image_path: str, prs, 
                    slide_index: int) -> Dict:
        """Обработка одного слайда"""
        
        try:
            grouper = HybridGrouper(slide, image_path, prs, slide_index)
            groups, metrics, params = grouper.process()
            
            if metrics.score < CONFIG["optimization"]["min_acceptable_score"]:
                return {
                    "slide_number": slide_index + 1,
                    "layout_groups": get_linear_content(slide),
                    "quality_metrics": metrics.to_dict(),
                    "used_parameters": params.to_dict(),
                    "processing_method": "linear_fallback"
                }
            
            return {
                "slide_number": slide_index + 1,
                "layout_groups": OutputConverter.convert(groups),
                "quality_metrics": metrics.to_dict(),
                "used_parameters": params.to_dict(),
                "processing_method": "hybrid_cv_structure"
            }
        
        except Exception as e:
            return {
                "slide_number": slide_index + 1,
                "layout_groups": get_linear_content(slide),
                "quality_metrics": {"score": 0, "error": str(e)},
                "processing_method": "error_fallback"
            }


# ==========================================
# ОСНОВНАЯ ФУНКЦИЯ ПАРСИНГА
# ==========================================

def parse_presentation(pptx_path: str, 
                       image_folder: str,
                       output_json: str) -> List[Dict]:
    """
    Основная функция парсинга презентации.
    
    Args:
        pptx_path: Путь к файлу PPTX
        image_folder: Папка для сохранения изображений слайдов
        output_json: Путь к выходному JSON файлу
    
    Returns:
        Список словарей с результатами парсинга для каждого слайда
    """
    print(f"Обработка: {pptx_path}")
    
    # Экспорт изображений
    print("Экспорт изображений слайдов...")
    images = SlideImageExporter.export(pptx_path, image_folder)
    
    if not images:
        raise ValueError("Не удалось экспортировать изображения слайдов")
    
    print(f"Экспортировано {len(images)} изображений")
    
    # Загрузка презентации
    prs = Presentation(pptx_path)
    parser = PresentationParser()
    
    results = []
    
    for i, slide in enumerate(prs.slides):
        print(f"Обработка слайда {i + 1}/{len(prs.slides)}...")
        
        if i >= len(images):
            print(f"  Предупреждение: нет изображения для слайда {i + 1}")
            result = {
                "slide_number": i + 1,
                "layout_groups": get_linear_content(slide),
                "processing_method": "no_image_fallback"
            }
        else:
            result = parser.parse_slide(slide, images[i], prs, i)
        
        results.append(result)
        
        method = result.get("processing_method", "unknown")
        score = result.get("quality_metrics", {}).get("score", "N/A")
        print(f"  Метод: {method}, Оценка: {score}")
    
    # Сохранение результатов
    print(f"Сохранение результатов в {output_json}...")
    with open(output_json, "w", encoding="utf-8") as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    # Статистика
    methods = defaultdict(int)
    scores = []
    
    for r in results:
        methods[r.get("processing_method", "unknown")] += 1
        if "quality_metrics" in r and isinstance(r["quality_metrics"], dict):
            if "score" in r["quality_metrics"]:
                scores.append(r["quality_metrics"]["score"])
    
    print("\n=== Статистика ===")
    print(f"Всего слайдов: {len(results)}")
    for method, count in methods.items():
        print(f"  {method}: {count}")
    if scores:
        print(f"Средняя оценка: {sum(scores) / len(scores):.3f}")
    
    print("Готово!")
    
    return results


# ==========================================
# ТОЧКА ВХОДА
# ==========================================

if __name__ == "__main__":
    PPTX_FILE = r""  # Укажите путь к файлу презентации
    IMG_FOLDER = "temp_images"
    JSON_OUTPUT = "final_output.json"
    
    result = parse_presentation(PPTX_FILE, IMG_FOLDER, JSON_OUTPUT)
